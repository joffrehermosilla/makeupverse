export default SingleState;
/**
 * @extends core/SingleState
 * @alias babylonjs/SingleState
 */
declare class SingleState {
    /**
     * @constructor
     *
     * @param {Object=} options - Options for the animation state.
     * @param {AnimationGroup} babylonGroup - The animation group that controls
     * playback of the animation.
     * @param {Scene} babylonScene - The scene containing the babylonGroup.
     **/
    constructor(options?: any | undefined, babylonGroup: AnimationGroup, babylonScene: Scene);
    /**
     * Pause the animation and reset counters once the animation finishes.
     *
     * @private
     */
    private _onFinishedEvent;
    /**
     * Increment loop counter for each animation loop. If loop counter meets
     * loopCount, notifiy that the animation has finished.
     *
     * @private
     */
    private _onLoopEvent;
    _from: any;
    _to: any;
    _babylonScene: Scene;
    _babylonAnimations: any[];
    _babylonAnimatables: any[];
    _babylonNumAnimations: number;
    _babylonLoopCount: number;
    _looped: number;
    _finished: number;
    _started: boolean;
    set normalizedTime(arg: number);
    get normalizedTime(): number;
    set timeScale(arg: any);
    get timeScale(): any;
    set loopCount(arg: any);
    get loopCount(): any;
    /**
     * Stop and discard of currently stored animatables and generate new ones that
     * are paused.
     *
     * @private
     */
    private _createAnimatables;
    /**
     * Reset variables and animations. Should be called before playing from the
     * beginning and if calling stop.
     *
     * @private
     */
    private _reset;
    _paused: boolean;
    updateInternalWeight(factor: any): void;
    play(onFinish: any, onError: any, onCancel: any): any;
    pause(): any;
    resume(onFinish: any, onError: any, onCancel: any): any;
    cancel(): any;
    stop(): any;
    discard(): void;
    deactivate(): void;
}
//# sourceMappingURL=SingleState.d.ts.map