/*! For license information please see host.core.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("HOST",[],t):"object"==typeof exports?exports.HOST=t():e.HOST=t()}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(()=>(()=>{"use strict";var e={6128:(e,t,i)=>{i.d(t,{O:()=>s});const s="core"}},t={};function i(s){var n=t[s];if(void 0!==n)return n.exports;var a=t[s]={exports:{}};return e[s](a,a.exports,i),a.exports}i.d=(e,t)=>{for(var s in t)i.o(t,s)&&!i.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var s={};return(()=>{i.r(s),i.d(s,{AbstractHostFeature:()=>c,AbstractSpeech:()=>$e,AbstractTextToSpeechFeature:()=>Ce,AnimationFeature:()=>fe,AnimationLayer:()=>Ee,AnimationTypes:()=>ve,AnimationUtils:()=>ke,AxisMap:()=>X,Blend1dState:()=>xe,Blend2dState:()=>Fe,DefaultGestureWords:()=>F,DefaultLayerBlendMode:()=>be,DefaultVisemeMap:()=>L,Deferred:()=>e,Easing:()=>ye,FreeBlendState:()=>Te,GestureFeature:()=>k,HostObject:()=>l,LayerBlendModes:()=>Se,LexFeature:()=>Oe,LexUtils:()=>Me,LipsyncFeature:()=>N,MathUtils:()=>r,Messenger:()=>h,PointOfInterestFeature:()=>ie,QueueState:()=>Le,RandomAnimationState:()=>Ne,SingleState:()=>Ae,Speech:()=>Ve,TextToSpeechFeature:()=>Ie,TextToSpeechUtils:()=>Pe,TransitionState:()=>we,Utils:()=>t,Version:()=>ge,env:()=>o.O});class Deferred extends Promise{constructor(e=(()=>{}),t,i,s){if("function"!=typeof e)throw new Error("Cannot create new Deferred. Executable must be a function.");if(void 0!==t&&"function"!=typeof t)throw new Error("Cannot create new Deferred. OnResolve must be a function.");if(void 0!==i&&"function"!=typeof i)throw new Error("Cannot create new Deferred. OnReject must be a function.");if(void 0!==s&&"function"!=typeof s)throw new Error("Cannot create new Deferred. OnCancel must be a function.");let n,a,r;const o={resolved:!1,rejected:!1,canceled:!1,pending:!0};super(((h,c)=>{n=e=>{if(o.pending)return o.resolved=!0,o.pending=!1,"function"==typeof t&&(e=t(e)),h(e)},a=e=>{if(o.pending)return o.rejected=!0,o.pending=!1,"function"==typeof i&&(e=i(e)),c(e)},r=e=>{if(o.pending)return o.canceled=!0,o.pending=!1,"function"==typeof s&&(e=s(e)),h(e)},e(n,a,r)})),this._status=o,this._resolve=n,this._reject=a,this._cancel=r,this._executable=e}get resolved(){return this._status.resolved}get rejected(){return this._status.rejected}get canceled(){return this._status.canceled}get pending(){return this._status.pending}resolve(e){return this._resolve(e)}reject(e){return this._reject(e)}cancel(e){return this._cancel(e)}execute(...e){this.pending&&this._executable(this._resolve,this._reject,this._cancel,...e)}static cancel(e){return new Deferred(((t,i,s)=>{s(e)}))}static all(e,t,i,s){if(null==e||"function"!=typeof e[Symbol.iterator]){let e="Cannot execute Deferred.all. First argument must be iterable.";return"function"==typeof i&&(e=i(e)),Deferred.reject(e)}const n=[...e],a=n.filter((e=>e instanceof Deferred)),r=new Deferred(void 0,(e=>(a.forEach((t=>{t.resolve(e)})),a.length=0,"function"==typeof t?t(e):e)),(e=>(a.forEach((t=>{t.reject(e)})),a.length=0,"function"==typeof i?i(e):e)),(e=>(a.forEach((t=>{t.cancel(e)})),a.length=0,"function"==typeof s?s(e):e))),o=n.length,h={failed:!1,numResolved:0,resolutions:[]};return n.forEach(((e,t)=>{if(!h.failed)return e instanceof Promise?void e.then((i=>{h.failed||e.canceled?h.failed||(h.failed=!0,r.cancel(i)):(h.resolutions[t]=i,h.numResolved+=1,h.numResolved===o&&r.resolve(h.resolutions))}),(e=>{h.failed||(h.failed=!0,r.reject(e))})):(h.resolutions[t]=e,h.numResolved+=1,void(h.numResolved===o&&r.resolve(h.resolutions)))})),r}}const e=Deferred;class Utils{static createId(){return"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g,(e=>{const t=Math.floor((Date.now()+16*Math.random())%16);return"x"===e?t.toString(16):(3&t|8).toString(16)}))}static getUniqueName(e,t=[]){if(!t.includes(e))return e;const i=new Set(t),s=e.match(/\d*$/),{index:n}=s,a=e.slice(0,n);let r=Number(s[0]);return i.forEach((e=>{const t=e.match(/\d*$/);if(e.slice(0,t.index)===a){const e=Number(t[0]);e>r&&(r=e)}})),`${a}${r+1}`}static wait(t=0,{onFinish:i,onProgress:s,onCancel:n,onError:a}={}){if("number"!=typeof t&&(console.warn(`Invalid seconds value ${t} for wait. Defaulting to 0.`),t=0),t<=0)return"function"==typeof i&&i(),e.resolve();let r=0;const o=1e3*t;return new e(((e,t,i,n=0)=>{if("number"==typeof n)0!==n&&(r+=n,r<0&&(r=0),"function"==typeof s&&s(Math.min(r/o,1)),r>=o&&e());else{t(new Error("Invalid property wait deltaTime. DeltaTime must be a number."))}}),i,a,n)}static getRandomFloat(e,t){return Math.random()*(t-e)+e}static getRandomInt(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e))+e}static addStringOnlyOnce(e,t){return null==e?t:-1!==e.indexOf(t)?e:e.concat(" ",t)}static addCoreUserAgentComponent(e){const t=`SumerianHosts-${Utils.getVersion()}`;return Utils.addStringOnlyOnce(e,t)}static getVersion(){return"b6e31beb34968627f139042d1bff2861ef3654b9"}}const t=Utils,n=180/Math.PI,a=Math.PI/180;class MathUtils{static toDegrees(e){return e*n}static toRadians(e){return e*a}static lerp(e,t,i){return e+(t-e)*i}static clamp(e,t=0,i=1){return Math.max(t,Math.min(e,i))}static closestPointOnLine(e,t,i){const s=MathUtils.distanceSquared(e,t);if(0===s)return e;const n=((i[0]-e[0])*(t[0]-e[0])+(i[1]-e[1])*(t[1]-e[1]))/s;let a=[...e];return n>1?a=[...t]:n>0&&(a=[e[0]+n*(t[0]-e[0]),e[1]+n*(t[1]-e[1])]),a}static distanceSquared(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])}static getDelaunayTriangulation(e){if(!e||e.length<3)throw new Error(`Cannot get delaunay triangulation for points ${e}. Input must contain at least three points.`);let t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;e.forEach((e=>{t=e[0]<t?e[0]:t,i=e[1]<i?e[1]:i,s=e[0]>s?e[0]:s,n=e[1]>n?e[1]:n}));const a=s-t,r=n-i,o=(t+s)/2,h=(i+n)/2,c=a>r?a:r,l=[e.length,e.length+1,e.length+2],u=[...e,[o-20*c,h-c],[o,h+20*c],[o+20*c,h-c]],d=MathUtils.sortPointsCCW(l,u),m=[{indices:d,edges:[[d[0],d[1]],[d[1],d[2]],[d[2],d[0]]]}];u.forEach(((e,t)=>{const i=[];m.forEach((t=>{MathUtils.isPointInCircumCircle(u[t.indices[0]],u[t.indices[1]],u[t.indices[2]],e)&&i.push(t)}));const s=[];i.forEach((e=>{e.edges.forEach((t=>{let n=0;i.forEach((i=>{e!==i&&i.edges.forEach((e=>{(t[0]===e[0]&&t[1]===e[1]||t[1]===e[0]&&t[0]===e[1])&&(n+=1)}))})),0===n&&s.push(t)}))})),i.forEach((e=>{m.splice(m.indexOf(e),1)})),s.forEach((e=>{const i=MathUtils.sortPointsCCW([e[0],e[1],t],u);m.push({indices:i,edges:[[i[0],i[1]],[i[1],i[2]],[i[2],i[0]]]})}))}));const _=[];return m.forEach((e=>{e.indices.forEach((t=>{l.includes(t)&&_.push(e)}))})),_.forEach((e=>{const t=m.indexOf(e);-1!==t&&m.splice(t,1)})),m.map((e=>e.indices))}static isPointInCircumCircle(e,t,i,s){const n=e[0]-s[0],a=e[1]-s[1],r=t[0]-s[0],o=t[1]-s[1],h=i[0]-s[0],c=i[1]-s[1];return(n*n+a*a)*(r*c-h*o)-(r*r+o*o)*(n*c-h*a)+(h*h+c*c)*(n*o-r*a)>0}static isPointInTriangle(e,t,i,s){const n=(t[1]-i[1])*(e[0]-i[0])+(i[0]-t[0])*(e[1]-i[1]),a=((t[1]-i[1])*(s[0]-i[0])+(i[0]-t[0])*(s[1]-i[1]))/n,r=((i[1]-e[1])*(s[0]-i[0])+(e[0]-i[0])*(s[1]-i[1]))/n,o=1-a-r;return a>=0&&a<=1&&r>=0&&r<=1&&o>=0&&o<=1}static sortPointsCCW(e,t){const i=[0,0];return e.forEach((e=>{i[0]+=t[e][0],i[1]+=t[e][1]})),i[0]/=e.length,i[1]/=e.length,e.sort(((e,s)=>{const n=Math.atan2(t[s][1]-i[1],t[s][0]-i[0]);return Math.atan2(t[e][1]-i[1],t[e][0]-i[0])-n})),e}static triangleArea(e,t,i){return Math.abs(.5*(e[0]*(t[1]-i[1])+t[0]*(i[1]-e[1])+i[0]*(e[1]-t[1])))}static getVectorMagnitude(e){if(!(e instanceof Array))throw new Error(`Cannot get magnitude for vector ${e}. Input must be an Array numbers.`);return Math.sqrt(e.reduce(((t,i)=>{if("number"!=typeof i)throw new Error(`Cannot get magnitude for vector ${e}. All items in the input Array must be numbers.`);return t+i**2}),0))}static getDotProduct(e,t){if(!(e instanceof Array&&t instanceof Array&&e.length===t.length))throw new Error(`Cannot get dot product between ${e} and ${t}. Inputs must be vectors of the same length.`);let i=0;return e.forEach(((s,n)=>{const a=t[n];if("number"!=typeof s||"number"!=typeof a)throw new Error(`Cannot get dot product between ${e} and ${t}. Vectors must only consist of numeric values.`);i+=s*a})),i}static getAngleBetween(e,t){const i=this.normalizeVector([...e]),s=this.normalizeVector([...t]),n=this.getDotProduct(i,s);return Math.acos(this.clamp(n,-1,1))}static rotateVector(e,t){if(!(e instanceof Array&&3===e.length&&e.every((e=>"number"==typeof e))))throw new Error(`Cannot rotate vector ${e} by rotation matrix ${t}. Input vector must be an array of 3 numbers.`);if(!(t instanceof Array&&9===t.length&&t.every((e=>"number"==typeof e))))throw new Error(`Cannot rotate vector ${e} by rotation matrix ${t}. Input matrix3 must be an array of 9 numbers.`);return[t[0]*e[0]+t[3]*e[1]+t[6]*e[2],t[1]*e[0]+t[4]*e[1]+t[7]*e[2],t[2]*e[0]+t[5]*e[1]+t[8]*e[2]]}static normalizeVector(e){const t=this.getVectorMagnitude(e);return 0===t?e.fill(0):e.forEach(((i,s)=>{e[s]=i/t})),e}static getRotationMatrix(e){if(!(e instanceof Array&&16===e.length&&e.every((e=>"number"==typeof e))))throw new Error(`Cannot convert matrix ${e} to a rotation matrix. Input matrix must be an array of 16 numbers.`);const t=1/(this.getVectorMagnitude(e.slice(0,4))||1),i=1/(this.getVectorMagnitude(e.slice(4,8))||1),s=1/(this.getVectorMagnitude(e.slice(8,12))||1);return[e[0]*t,e[1]*t,e[2]*t,e[4]*i,e[5]*i,e[6]*i,e[8]*s,e[9]*s,e[10]*s]}static cartesianToSpherical(e,t,i){const s=this.getVectorMagnitude([e,t,i]);return 0===s?[0,0,0]:[s,Math.acos(this.clamp(t/s,-1,1)),Math.atan2(e,i)]}static dampValue(e,t,i=[0,0],s=1e-7,n=.3,a=1e7){n=Math.max(1e-4,n),s=Math.max(1e-7,s);const r=a*n,o=e-t,h=this.clamp(o,-r,r),c=e-h,l=2/n,u=l*s,d=1/(1+u+.5*u**2+.25*u**3),m=(i[1]+l*h)*s;return i[0]=c+(h+m)*d,i[1]=(i[1]-l*m)*d,t-e>0==i[0]>t&&(i[0]=t,i[1]=(i[0]-t)/s),i}}const r=MathUtils;var o=i(6128);class Messenger{constructor(e){this._id=void 0!==e?e:t.createId(),this._dispatcher=window,this._callbacks={},this._eventListeners={}}get id(){return this._id}_createLocalMessage(e){return`${this.id}.${e}`}_createListener(e){return t=>{let i;null!==t.detail&&(i=t.detail),e(i)}}_createEvent(e,t){return new CustomEvent(e,{detail:t})}_addListener(e,t){this._dispatcher.addEventListener(this._createLocalMessage(e),t)}_removeListener(e,t){this._dispatcher.removeEventListener(this._createLocalMessage(e),t)}listenTo(e,t){if("function"!=typeof t)throw new Error(`Cannot add listener for ${e} on ${this.id}. Callback must be a function.`);void 0===this._callbacks[e]&&(this._callbacks[e]=[],this._eventListeners[e]=[]);const i=this._createListener(t);this._callbacks[e].push(t),this._eventListeners[e].push(i),this._addListener(e,i)}stopListening(e,t){if(void 0===this._callbacks[e])return;if(void 0===t){for(let t=this._callbacks[e].length-1;t>-1;t--)this.stopListening(e,this._callbacks[e][t]);return}const i=this._callbacks[e].indexOf(t);if(-1===i)return;const s=this._eventListeners[e][i];this._removeListener(e,s),this._callbacks[e].splice(i,1),this._eventListeners[e].splice(i,1),0===this._callbacks[e].length&&(delete this._callbacks[e],delete this._eventListeners[e])}stopListeningByRegexp(e,t){Object.keys(this._callbacks).filter((t=>e.test(t))).forEach((e=>{this.stopListening(e,t)}))}stopListeningToAll(){const e=Object.keys(this._callbacks);for(let t=e.length-1;t>-1;t--)this.stopListening(e[t])}emit(e,t){if(void 0===this._callbacks[e])return;e=this._createLocalMessage(e);const i=this._createEvent(e,t);this._dispatcher.dispatchEvent(i)}static listenTo(e,t,i){this.GlobalMessenger.listenTo(e,t,i)}static stopListening(e,t){this.GlobalMessenger.stopListening(e,t)}static stopListeningByRegexp(e,t){Object.keys(this.GlobalMessenger._callbacks).filter((t=>e.test(t))).forEach((e=>{this.stopListening(e,t)}))}static stopListeningToAll(){this.GlobalMessenger.stopListeningToAll()}static emit(e,t){this.GlobalMessenger.emit(e,t)}}Object.defineProperties(Messenger,{GlobalMessenger:{value:new Messenger,writable:!1},EVENTS:{value:{},writable:!1}});const h=Messenger;class AbstractHostFeature{constructor(e){this._host=e}installApi(){const e={},t={EVENTS:e};return Object.entries(this.constructor.EVENTS).forEach((([t,i])=>{e[t]=`${this.constructor.name}.${i}`})),this._host[this.constructor.name]=t,t}get host(){return this._host}get owner(){return this._host.owner}listenTo(e,t){this._host.listenTo(e,t)}static listenTo(e,t){e=`${this.name}.${e}`,h.listenTo(e,t)}stopListening(e,t){this._host.stopListening(e,t)}static stopListening(e,t){e=`${this.name}.${e}`,h.stopListening(e,t)}stopListeningByRegexp(e,t){this._host.stopListeningByRegexp(e,t)}static stopListeningByRegexp(e,t){e=new RegExp(`^${this.name}.${e.source.replace(/\^/,"")}`),h.stopListeningByRegexp(e,t)}stopListeningToAll(){this._host.stopListeningToAll()}static stopListeningToAll(){h.stopListeningByRegexp(new RegExp(`^${this.name}.`))}emit(e,t){e=`${this.constructor.name}.${e}`,this._host.emit(e,t)}static emit(e,t){e=`${this.name}.${e}`,h.emit(e,t)}update(e){this.emit(this.constructor.EVENTS.update,e)}discard(){Object.keys(this._host[this.constructor.name]).forEach((e=>{delete this._host[this.constructor.name][e]})),delete this._host[this.constructor.name],delete this._host}static mix(...e){let t=this;return e.forEach((e=>{t=e(t)})),t}}Object.defineProperties(AbstractHostFeature,{EVENTS:{value:{update:"onUpdate"},writable:!1},SERVICES:{value:{},writable:!1}});const c=AbstractHostFeature;class HostObject extends h{constructor({owner:e={}}={}){super(e.id),this._owner=e,this._features={},this._waits=[],this._lastUpdate=this.now}get owner(){return this._owner}get now(){return Date.now()}get deltaTime(){return this.now-this._lastUpdate}update(){const e=this.now,t=this.deltaTime;this._waits.forEach((e=>{e.execute(t)})),Object.values(this._features).forEach((e=>{e.update(t)})),this.emit(this.constructor.EVENTS.update,t),this._lastUpdate=e}wait(e,{onFinish:i,onProgress:s,onCancel:n,onError:a}={}){const r=t.wait(e,{onFinish:i,onProgress:s,onCancel:n,onError:a});this._waits.push(r);const o=()=>{this._waits.splice(this._waits.indexOf(r),1)};return r.then(o,o),r}addFeature(e,t=!1,...i){if("function"!==typeof e)throw new Error(`Cannot add feature to host ${this.id}. FeatureClass must be a class.`);if(!(e.prototype instanceof c))throw new Error(`Cannot add feature ${e.name} to host ${this.id}. FeatureClass must extend AbstractHostFeature.`);if(void 0!==this._features[e.name]){if(!t)throw new Error(`Feature ${e.name} already exists on host ${this.id}. Use 'force' argument to overwrite the feature.`);console.warn(`Feature ${e.name} already exists on host ${this.id}. Existing feature will be overwritten.`)}const s=new e(this,...i);return s.installApi(),this._features[e.name]=s,this.emit(this.constructor.EVENTS.addFeature,e.name),!0}removeFeature(e){return void 0===this._features[e]?(console.warn(`Feature of type ${e} does not exist on host ${this.id}. No feature will be removed.`),!1):(this.emit(this.constructor.EVENTS.removeFeature,e),this._features[e].discard(),delete this._features[e],!0)}hasFeature(e){return!!this._features[e]}listFeatures(){return Object.keys(this._features)}}Object.defineProperty(HostObject,"EVENTS",{value:{...Object.getPrototypeOf(HostObject).EVENTS,update:"onUpdate",addFeature:"onAddFeature",removeFeature:"onRemoveFeature"},writable:!1});const l=HostObject,u={None:e=>e,In:e=>e,Out:e=>e,InOut:e=>e},d={In:e=>e*e,Out:e=>e*(2-e),InOut:e=>(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)},m={In:e=>e*e*e,Out:e=>--e*e*e+1,InOut:e=>(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)},_={In:e=>e*e*e*e,Out:e=>1- --e*e*e*e,InOut:e=>(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)},p={In:e=>e*e*e*e*e,Out:e=>--e*e*e*e*e+1,InOut:e=>(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)},g={In:e=>1-Math.cos(e*Math.PI/2),Out:e=>Math.sin(e*Math.PI/2),InOut:e=>.5*(1-Math.cos(Math.PI*e))},y={In:e=>0===e?0:1024**(e-1),Out:e=>1===e?1:1-2**(-10*e),InOut:e=>0===e?0:1===e?1:(e*=2)<1?.5*1024**(e-1):.5*(2-2**(-10*(e-1)))},f={In:e=>1-Math.sqrt(1-e*e),Out:e=>Math.sqrt(1- --e*e),InOut:e=>(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):(e-=2,.5*(Math.sqrt(1-e*e)+1))},v={In(e){let t,i=.1;return 0===e?0:1===e?1:(!i||i<1?(i=1,t=.1):t=.4*Math.asin(1/i)/(2*Math.PI),-i*2**(10*(e-=1))*Math.sin((e-t)*(2*Math.PI)/.4))},Out(e){let t,i=.1;return 0===e?0:1===e?1:(!i||i<1?(i=1,t=.1):t=.4*Math.asin(1/i)/(2*Math.PI),i*2**(-10*e)*Math.sin((e-t)*(2*Math.PI)/.4)+1)},InOut(e){let t,i=.1;const s=.4;return 0===e?0:1===e?1:(!i||i<1?(i=1,t=.1):t=s*Math.asin(1/i)/(2*Math.PI),(e*=2)<1?i*2**(10*(e-=1))*Math.sin((e-t)*(2*Math.PI)/s)*-.5:i*2**(-10*(e-=1))*Math.sin((e-t)*(2*Math.PI)/s)*.5+1)}},E={In(e){const t=1.70158;return e*e*((t+1)*e-t)},Out(e){const t=1.70158;return--e*e*((t+1)*e+t)+1},InOut(e){const t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}},S={In:e=>1-S.Out(1-e),Out:e=>e<1/2.75?7.5625*e*e:e<2/2.75?(e-=1.5)/2.75*7.5625*e+.75:e<2.5/2.75?(e-=2.25)/2.75*7.5625*e+.9375:(e-=2.625)/2.75*7.5625*e+.984375,InOut:e=>e<.5?.5*S.In(2*e):.5*S.Out(2*e-1)+.5};class FeatureDependentInterface{_onFeatureAdded(e){}_onFeatureRemoved(e){}discard(){}static Mixin(e){const t=class extends e{constructor(e){super(e),this._host=e,this._initialized||(this._initialized=!0,this._onFeatureAdded=this._onFeatureAdded.bind(this),this._onFeatureRemoved=this._onFeatureRemoved.bind(this),this._host.listenTo(l.EVENTS.addFeature,this._onFeatureAdded),this._host.listenTo(l.EVENTS.removeFeature,this._onFeatureRemoved),Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach((e=>{void 0!==this._host[e]&&this._onFeatureAdded(e)})))}_onFeatureAdded(e){if(void 0!==this.constructor.EVENT_DEPENDENCIES[e]){const t=this.constructor.EVENT_DEPENDENCIES[e];Object.entries(t).forEach((([t,i])=>{this[i]=this[i].bind(this),this._host.listenTo(this._host[e].EVENTS[t],this[i])}))}}_onFeatureRemoved(e){if(void 0!==this.constructor.EVENT_DEPENDENCIES[e]){const t=this.constructor.EVENT_DEPENDENCIES[e];Object.entries(t).forEach((([t,i])=>{this._host.stopListening(this._host[e].EVENTS[t],this[i])}))}}discard(){this._host.stopListening(l.EVENTS.addFeature,this._onFeatureAdded),this._host.stopListening(l.EVENTS.removeFeature,this._onFeatureRemoved),Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach((e=>{void 0!==this._host[e]&&this._onFeatureRemoved(e)})),super.discard()}},i=e.EVENT_DEPENDENCIES||{};return Object.defineProperties(t,{EVENT_DEPENDENCIES:{value:{...i},writable:!1}}),t}}Object.defineProperties(FeatureDependentInterface,{EVENT_DEPENDENCIES:{value:{},writable:!1}});const b=FeatureDependentInterface;class AnimationFeatureDependentInterface extends b{_onLayerAdded({name:e}){}_onLayerRemoved({name:e}){}_onLayerRenamed({oldName:e,newName:t}){}_onAnimationAdded({layerName:e,animationName:t}){}_onAnimationRemoved({layerName:e,animationName:t}){}_onAnimationRenamed({layerName:e,oldName:t,newName:i}){}static Mixin(e){const t=b.Mixin(e),i=class extends t{_onLayerAdded({name:e}){}_onLayerRemoved({name:e}){}_onLayerRenamed({oldName:e,newName:t}){}_onAnimationAdded({layerName:e,animationName:t}){}_onAnimationRemoved({layerName:e,animationName:t}){}_onAnimationRenamed({layerName:e,oldName:t,newName:i}){}};return Object.defineProperties(i,{EVENT_DEPENDENCIES:{value:{...t.EVENT_DEPENDENCIES,...AnimationFeatureDependentInterface.EVENT_DEPENDENCIES},writable:!1}}),i}}Object.defineProperties(AnimationFeatureDependentInterface,{EVENT_DEPENDENCIES:{value:{AnimationFeature:{addLayer:"_onLayerAdded",removeLayer:"_onLayerRemoved",renameLayer:"_onLayerRenamed",addAnimation:"_onAnimationAdded",removeAnimation:"_onAnimationRemoved",renameAnimation:"_onAnimationRenamed"}},writable:!1}});const A=AnimationFeatureDependentInterface;class ManagedAnimationLayerInterface extends A{registerLayer(e,t={}){}registerAnimation(e,t,i={}){}setLayerWeights(e=(()=>!0),t,i,s){}enable(e,t){}disable(e,t){}static Mixin(e){const t=A.Mixin(e),i=class extends t{constructor(...e){super(...e),this._managedLayers={}}_onFeatureAdded(e){super._onFeatureAdded(e),"AnimationFeature"===e&&(this._managedLayers=this._managedLayers||{},this._host.AnimationFeature.layers.forEach((e=>{this._onLayerAdded({name:e})})))}_onFeatureRemoved(e){super._onFeatureRemoved(e),"AnimationFeature"===e&&(this._managedLayers=this._managedLayers||{},Object.keys(this._managedLayers).forEach((e=>{this._onLayerRemoved({name:e})})))}_onLayerAdded({name:e}){void 0!==this._managedLayers[e]&&(this._managedLayers[e].isActive=!0,this._host.AnimationFeature.getAnimations(e).forEach((t=>{this._onAnimationAdded({layerName:e,animationName:t})})))}_onLayerRemoved({name:e}){void 0!==this._managedLayers[e]&&(this._managedLayers[e].isActive=!1,Object.keys(this._managedLayers[e].animations).forEach((t=>{this._onAnimationRemoved({layerName:e,animationName:t})})))}_onLayerRenamed({oldName:e,newName:t}){const i=this._managedLayers[e];void 0!==i&&(delete this._managedLayers[e],this._managedLayers[t]=i)}_onAnimationAdded({layerName:e,animationName:t}){void 0!==this._managedLayers[e]&&void 0!==this._managedLayers[e].animations[t]&&(this._managedLayers[e].animations[t].isActive=!0)}_onAnimationRemoved({layerName:e,animationName:t}){void 0!==this._managedLayers[e]&&void 0!==this._managedLayers[e].animations[t]&&(this._managedLayers[e].animations[t].isActive=!1)}_onAnimationRenamed({layerName:e,oldName:t,newName:i}){if(void 0!==this._managedLayers[e]&&void 0!==this._managedLayers[e].animations[t]){const s=this._managedLayers[e].animations[t];delete this._managedLayers[e].animations[t],this._managedLayers[e].animations[i]=s}}registerLayer(e,t={}){void 0===this._managedLayers[e]&&(this._managedLayers[e]={...this.constructor.DEFAULT_LAYER_OPTIONS,animations:{}});const i=this._managedLayers[e],s=(t={...t}).animations||{};delete t.animations,Object.assign(i,t),i.isActive=void 0!==this._host.AnimationFeature&&this._host.AnimationFeature.layers.includes(e),Object.entries(s).forEach((([t,i])=>{this.registerAnimation(e,t,i)}))}registerAnimation(e,t,i={}){void 0===this._managedLayers[e]&&this.registerLayer(e);const s=this._managedLayers[e].animations[t]||{};Object.assign(s,i),this._managedLayers[e].animations[t]=s,this._managedLayers[e].animations[t].isActive=this._managedLayers[e].isActive&&this._host.AnimationFeature.getAnimations(e).includes(t)}setLayerWeights(e=(()=>!0),t,i,s){Object.keys(this._managedLayers).filter(e).forEach((e=>{const n=this._managedLayers[e];n.isActive&&this._host.AnimationFeature.setLayerWeight(e,t,void 0!==i?i:n.blendTime,s||n.easingFn)}))}enable(e,t){this.setLayerWeights(void 0,1,e,t)}disable(e,t){this.setLayerWeights(void 0,0,e,t)}installApi(){const e=super.installApi();return Object.assign(e,{registerLayer:this.registerLayer.bind(this),registerAnimation:this.registerAnimation.bind(this),setLayerWeights:this.setLayerWeights.bind(this),enable:this.enable.bind(this),disable:this.disable.bind(this)}),e}};return Object.defineProperties(i,{DEFAULT_LAYER_OPTIONS:{value:ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS,writable:!1}}),i}}Object.defineProperties(ManagedAnimationLayerInterface,{DEFAULT_LAYER_OPTIONS:{value:{blendTime:.5,animations:{}},writable:!1}});const w=ManagedAnimationLayerInterface;class TextToSpeechFeatureDependentInterface extends b{_onPlay(){}_onPause(){}_onResume(){}_onStop(){}_onSentence(){}_onWord(){}_onViseme(){}_onSsml(){}static Mixin(e){const t=b.Mixin(e),i=class extends t{_onPlay(){}_onPause(){}_onResume(){}_onStop(){}_onSentence(){}_onWord(){}_onViseme(){}_onSsml(){}};return Object.defineProperties(i,{EVENT_DEPENDENCIES:{value:{...t.EVENT_DEPENDENCIES,...TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES},writable:!1}}),i}}Object.defineProperties(TextToSpeechFeatureDependentInterface,{EVENT_DEPENDENCIES:{value:{TextToSpeechFeature:{play:"_onPlay",pause:"_onPause",resume:"_onResume",stop:"_onStop",sentence:"_onSentence",word:"_onWord",viseme:"_onViseme",ssml:"_onSsml"}},writable:!1}});const T=TextToSpeechFeatureDependentInterface,L={sil:{name:"sil"},p:{name:"p",overrideWeight:.9},t:{name:"t",blendTime:.2},S:{name:"S"},T:{name:"T"},f:{name:"f",overrideWeight:.75},k:{name:"k"},i:{name:"i"},r:{name:"r"},s:{name:"s",blendTime:.25},u:{name:"u"},"@":{name:"@"},a:{name:"a"},e:{name:"e",blendTime:.2},E:{name:"E"},o:{name:"o"},O:{name:"O"}};class LipsyncFeature extends(c.mix(T.Mixin,w.Mixin)){constructor(e,{blendTime:t=.15,decayRate:{amount:i=.5,seconds:s=.5}={},easingFn:n=d.InOut,layers:a=[]}={},{blendTime:r=.75,easingFn:o=d.InOut,layers:h=[]}={},c=.067){super(e),this._visemeLayers={},this._talkingLayers={},this.visemeLeadTime=c,a.forEach((({name:e,animation:a,visemeMap:r=L})=>{this.registerVisemeLayer(e,{animation:a,visemeMap:r,decayRate:{amount:i,seconds:s},blendTime:t,easingFn:n})})),h.forEach((({name:e,animation:t})=>{this.registerTalkingLayer(e,{animation:t,blendTime:r,easingFn:o})}))}_registerVisemeAnimation(e,t){if(this._managedLayers[e].animations[t].isActive)if("freeBlend"!==this._host.AnimationFeature.getAnimationType(e,t))console.warn(`Cannot register Lipsync viseme animation ${t} on layer ${e} for host ${this._host.id}. Viseme animations must be of type 'freeBlend'.`),this._managedLayers[e].animations[t].isActive=!1;else{const i=this._host.AnimationFeature.getAnimationBlendNames(e,t),{visemeMap:s}=this._managedLayers[e].animations[t];Object.values(s).forEach((e=>{e.isActive=i.includes(e.name)}))}}_onFeatureAdded(e){this._visemeLayers=this._visemeLayers||{},this._talkingLayers=this._talkingLayers||{},super._onFeatureAdded(e),"TextToSpeechFeature"===e&&(this._host.TextToSpeechFeature.speechmarkOffset=-this._visemeLeadTime||0)}_onLayerAdded({name:e}){super._onLayerAdded({name:e}),void 0!==this._visemeLayers[e]&&this._registerVisemeAnimation(e,this._visemeLayers[e])}_onAnimationAdded({layerName:e,animationName:t}){super._onAnimationAdded({layerName:e}),this._visemeLayers[e]===t&&this._registerVisemeAnimation(e,this._visemeLayers[e])}_onPlay(){this.enable(),[this._visemeLayers,this._talkingLayers].forEach((e=>{Object.entries(e).forEach((([e,t])=>{this._managedLayers[e].animations[t].isActive&&this._host.AnimationFeature.resumeAnimation(e,t)}))}))}_onPause(){this._onStop()}_onResume(){this._onPlay()}_onStop(){this.disable(),[this._visemeLayers,this._talkingLayers].forEach((e=>{Object.entries(e).forEach((([e,t])=>{this._managedLayers[e].animations[t].isActive&&this._host.AnimationFeature.pauseAnimation(e,t)}))}))}async _onViseme({mark:e}){Object.entries(this._visemeLayers).forEach((([t,i])=>{const{isActive:s,visemeMap:n}=this._managedLayers[t].animations[i];if(!s)return;const{name:a,isActive:o,decayRate:h,blendTime:c,easingFn:l,overrideWeight:u}={...this._managedLayers[t],...n[e.value]},d=this._host.AnimationFeature.getAnimationBlendNames(t,i);if(!o||!d.includes(a))return;let m=1;const _=e.duration/1e3;if(_<c){const e=c>0?_/c:1;m=void 0!==u?u:r.lerp(0,1,e)}const p=Math.min(_,c),g=_-c;if(g<0)this._animateSimpleViseme(t,i,a,m,p,c,l);else{const e=h.seconds>0?g/h.seconds:1,s=r.lerp(m,m*h.amount,Math.min(1,e));this._animateHeldViseme(t,i,a,m,s,p,g,c,l)}}))}_animateSimpleViseme(e,t,i,s,n,a,r){const o=this._host.AnimationFeature.setAnimationBlendWeight(e,t,i,s,n,r);o.then((()=>{o.canceled||this._host.AnimationFeature.setAnimationBlendWeight(e,t,i,0,a,r)}))}async _animateHeldViseme(e,t,i,s,n,a,r,o,h){const c=this._host.AnimationFeature.setAnimationBlendWeight(e,t,i,s,a,h);if(await c,!c.canceled){const s=this._host.AnimationFeature.setAnimationBlendWeight(e,t,i,n,r,h);await s,s.canceled||this._host.AnimationFeature.setAnimationBlendWeight(e,t,i,0,o,h)}}get visemeLeadTime(){return this._visemeLeadTime}set visemeLeadTime(e){this._visemeLeadTime=e,this._host.TextToSpeechFeature&&(this._host.TextToSpeechFeature.speechmarkOffset=-e)}registerVisemeLayer(e,{animation:t="visemes",decayRate:i={amount:.5,seconds:.5},blendTime:s=LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime,easingFn:n,visemeMap:a=L}={}){this.registerLayer(e,{decayRate:i,blendTime:s,easingFn:n,animations:{[t]:{visemeMap:a}}}),this._visemeLayers[e]=t,this._registerVisemeAnimation(e,t)}registerTalkingLayer(e,{animation:t="stand_talk",blendTime:i=LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime,easingFn:s}={}){this.registerLayer(e,{blendTime:i,easingFn:s,animations:{[t]:{}}}),this._talkingLayers[e]=t}installApi(){const e=super.installApi();return Object.assign(e,{registerVisemeLayer:this.registerVisemeLayer.bind(this),registerTalkingLayer:this.registerTalkingLayer.bind(this)}),Object.defineProperty(e,"visemeLeadTime",{get:()=>this.visemeLeadTime,set:e=>{this.visemeLeadTime=e}}),e}}const N=LipsyncFeature;const x=class SSMLSpeechmarkInterface extends T{_onSsml({mark:e}){}static Mixin(e){const t=T.Mixin(e);return class extends t{_onSsml({mark:e}){try{const{feature:t,method:i,args:s}=JSON.parse(e.value);if(this.constructor.name===t){const e=this[i];e&&"function"==typeof e?e.apply(this,s):console.warn(`Function ${i} does not exist within feature ${t}`)}}catch(e){}}}}},F={big:["add","above","authority","big","cover","full","fly","grow","growth","high","huge","increase","major","majority","large","leader","lot","raise","rise","tall"],heart:["accept","admit","believe","care","feeling","feel","friend","grateful","happy","heart","human","pain","save","safe","kind","love"],in:["include","including","inside","into","now","near","nearest","closest","therein","within"],many:["all","always","any","anyone","among","area","around","beautiful","entire","environment","environments","environmental","everybody","everyone","everything","audience","total","group","groups","million","millions","others","billion","billions","hundred","hundreds","many","thousand","thousands","world","worlds","outside","reveal"],movement:["away","across","ahead","along","far","fast","follow","go","leave","move","movement","through","throughout","toward","travel","turned","passed"],one:["single","one","once","first","firstly","only","solo","warned","truly","up","alone"],aggressive:["power","powers","powerful","assert","assertive","strong","stronger","strongest","strength","flex","dang","damn","damnit","darn","shucks","doh","drat","angry","angrier","angriest","aggressive","annoyed","annoying","attack","attacking","offense","offensive","battle"],you:["you","yall","y'all","your","yours","thou","thy"],defense:["defense","fear","repulsed","scared","scary","scarier","scariest","fearful","afraid","cower","cowers","cowering","hideous","doomed","terrified","terrify","terrifying","terrifies","spooky","spookier","spookiest"],wave:["hello","hi","hiya","howdy","welcome","aloha","heya","hey","bye","goodbye","hola","adios","chao"],self:["my","I","myself","self","I've","Ive","me","mine","own"]};class GestureFeature extends(c.mix(x.Mixin,w.Mixin)){constructor(e,{holdTime:t=3,minimumInterval:i=1,layers:s={}}={}){super(e),this.holdTime=t,this.minimumInterval=i,Object.entries(s).forEach((([e,t={}])=>{this.registerLayer(e,t)}))}_getHoldTime(e,t){const i=void 0!==e.holdTime?e.holdTime:this.holdTime;return void 0!==t.holdTime?t.holdTime:i}_getMinimumInterval(e,t){const i=void 0!==e.minimumInterval?e.minimumInterval:this.minimumInterval;return void 0!==t.minimumInterval?t.minimumInterval:i}_onNext({layerName:e,animationName:i,canAdvance:s,isQueueEnd:n}){const a=this._managedLayers[e];if(void 0===a)return;const r=a.animations[i];if(void 0!==r&&!s&&!n&&a.currentGesture===i){const s=this._getHoldTime(a,r);a.holdTimer.cancel(),s<=0?this._host.AnimationFeature.playNextAnimation(e,i):a.holdTimer=t.wait(s,{onFinish:()=>{a.currentGesture===i&&this._host.AnimationFeature.playNextAnimation(e,i)}})}}_onStop({layerName:e,animationName:t}){const i=this._managedLayers[e];if(void 0===i)return;void 0!==i.animations[t]&&t===i.currentGesture&&(i.currentGesture=null,i.playTimer=null,i.holdTimer.cancel(),i.autoDisable&&this.setLayerWeights((t=>t===e),0))}_onAnimationAdded({layerName:e,animationName:t}){const i=this._managedLayers[e];if(void 0!==i){const s=i.animations[t];void 0===s?this.registerAnimation(e,t):s.isActive=!0}}registerLayer(t,i={}){super.registerLayer(t,{...i,holdTimer:e.resolve(),playTimer:null,currentGesture:null}),this._managedLayers[t].isActive&&this._host.AnimationFeature.getAnimations(t).forEach((e=>{void 0===this._managedLayers[t].animations[e]&&this.registerAnimation(t,e,this._managedLayers[t].animations[e])}))}registerAnimation(e,t,i={}){i.words instanceof Array||i.words instanceof Set||(i.words=F[t]||[]),super.registerAnimation(e,t,i)}createGestureMap(){const e={};return Object.entries(this._managedLayers).forEach((([t,{animations:i}])=>{Object.entries(i).forEach((([i,{holdTime:s,minimumInterval:n,words:a,transitionTime:r}])=>{if(a.length){const o={...s&&{holdTime:s},...n&&{minimumInterval:n},...r&&{transitionTime:r}},h={feature:this.constructor.name,method:"playGesture",args:[t,i,o]};e[JSON.stringify(h)]=a}}))})),e}createGenericGestureArray(e){const t=[];return(e=e||Object.keys(this._managedLayers)).forEach((e=>{const i=this._managedLayers[e];i&&Object.entries(i.animations).forEach((([i,{holdTime:s,minimumInterval:n,words:a,transitionTime:r}])=>{if(!a.length){const a={...s&&{holdTime:s},...n&&{minimumInterval:n},...r&&{transitionTime:r}},o=JSON.stringify({feature:this.constructor.name,method:"playGesture",args:[e,i,a]});t.includes(o)||t.push(o)}}))})),t}playGesture(t,i,{holdTime:s,minimumInterval:n,transitionTime:a,force:r=!1}={}){void 0!==this._managedLayers[t]&&void 0!==this._managedLayers[t].animations[i]||this.registerAnimation(t,i,{holdTime:s,minimumInterval:n,transitionTime:a});const o=this._managedLayers[t],h=o.animations[i];if(!h.isActive){const s=o.isActive?"animation":"layer",n=`Skipping gesture ${i} on layer ${t} for host ${this._host.id}. No ${s} exists with this name yet.`;return console.warn(n),e.cancel({reason:"inactive",value:s})}const{currentGesture:c}=o;if(c===i&&!r){const s=`Skipping gesture ${i} on layer ${t} for host ${this._host.id}. The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.`;return console.warn(s),e.cancel({reason:"playing",value:i})}return void 0!==s&&(h.holdTime=s),void 0!==n?h.minimumInterval=n:n=this._getMinimumInterval(o,h),!r&&null!==o.playTimer&&o.playTimer<n?(console.warn(`Skipping gesture ${i} on layer ${t} for host ${this._host.id}. Minimum interval ${n} has not been met.`),e.cancel({reason:"minimumInterval",value:n-o.playTimer})):(o.currentGesture=i,o.playTimer=0,o.holdTimer.cancel(),o.autoDisable&&this.setLayerWeights((e=>e===t),1),this._host.AnimationFeature.playAnimation(t,i,a))}update(e){super.update(e),Object.entries(this._managedLayers).forEach((([t,i])=>{i.isActive&&!this._host.AnimationFeature.getPaused(t)&&(i.holdTimer.execute(e),null!==i.playTimer&&(i.playTimer+=e/1e3))}))}installApi(){const e=super.installApi();Object.assign(e,{createGestureMap:this.createGestureMap.bind(this),createGenericGestureArray:this.createGenericGestureArray.bind(this),playGesture:this.playGesture.bind(this)})}}Object.defineProperties(GestureFeature,{DEFAULT_LAYER_OPTIONS:{value:{...GestureFeature.DEFAULT_LAYER_OPTIONS,autoDisable:!0},writable:!1},EVENT_DEPENDENCIES:{value:{...GestureFeature.EVENT_DEPENDENCIES,AnimationFeature:{...GestureFeature.EVENT_DEPENDENCIES.AnimationFeature,playNextAnimation:"_onNext",stopAnimation:"_onStop",interruptAnimation:"_onStop"}}}});const k=GestureFeature;const O=class AnimationUtils{static lerp(e,t,i){return console.warn("AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead."),r.lerp(e,t,i)}static clamp(e,t=0,i=1){return console.warn("AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead."),r.clamp(e,t,i)}static interpolateProperty(i,s,n,{seconds:a=0,easingFn:o,onFinish:h,onProgress:c,onCancel:l,onError:d}={}){if(!(i instanceof Object)){const t=new Error(`Cannot interpolate property ${s}. Property owner must be an object.`);return"function"==typeof d&&d(t),e.reject(t)}if(Number.isNaN(Number(i[s]))){const t=new Error(`Cannot interpolate property ${s}. Property must be numeric.`);return"function"==typeof d&&d(t),e.reject(t)}if(Number.isNaN(Number(n))){const t=new Error(`Cannot interpolate property ${s} to value ${n}. Target value must be numeric.`);return"function"==typeof d&&d(t),e.reject(t)}const m=i[s];if(m===n)return"function"==typeof h&&h(n),e.resolve(n);"function"!=typeof o&&(void 0!==o&&console.warn("Invalid property interpolation easingFn. Defaulting to linear interpolation."),o=u.InOut);const _=t.wait(a,{onFinish:()=>{i[s]=n,"function"==typeof h&&h(n)},onCancel:()=>{"function"==typeof l&&l(i[s])},onProgress:e=>{if(i[s]!==n){const t=o(e);if("number"!=typeof t){const e=new Error("Invalid property interpolation easingFn. EasingFn must return a number.");return void _.reject(e)}i[s]=r.lerp(m,n,t)}"function"==typeof c&&c(i[s]),1===e&&(i[s]=n,_.resolve(n))},onError:d});return _}};const M=class AbstractState{constructor(t={}){this.name=void 0!==t.name?t.name:this.constructor.name,this._weight=void 0!==t.weight?r.clamp(t.weight,0,1):0,this._internalWeight=this._weight,this._paused=!1,this._promises={finish:e.resolve(),weight:e.resolve(),play:e.resolve()},this._playCallbacks={onFinish:void 0,onError:void 0,onCancel:void 0}}get paused(){return this._paused}get weight(){return this._weight}set weight(e){this._weight=r.clamp(e,0,1)}get weightPending(){return this._promises.weight&&this._promises.weight.pending}setWeight(e,t=0,i){return this._promises.weight.cancel(),e=r.clamp(e),this._promises.weight=O.interpolateProperty(this,"weight",e,{seconds:t,easingFn:i}),this._promises.weight}get internalWeight(){return this._internalWeight}updateInternalWeight(e){this._internalWeight=this._weight*e}update(e){this._paused||Object.values(this._promises).forEach((t=>{t.execute(e)}))}play(t,i,s){return this._paused=!1,this._playCallbacks.onFinish=t,this._playCallbacks.onError=i,this._playCallbacks.onCancel=s,this._promises.play=new e(void 0,t,i,s),this._promises.finish=e.all([this._promises.play,this._promises.weight]),this._promises.finish}pause(){return this._paused=!0,!0}resume(t,i,s){return this._paused=!1,this._promises.play.pending||(this._playCallbacks.onFinish=t||this._playCallbacks.onFinish,this._playCallbacks.onError=i||this._playCallbacks.onError,this._playCallbacks.onCancel=s||this._playCallbacks.onCancel,this._promises.play=new e(void 0,this._playCallbacks.onFinish,this._playCallbacks.onError,this._playCallbacks.onCancel),this._promises.finish=e.all([this._promises.play,this._promises.weight])),this._promises.finish}cancel(){return this._paused=!0,Object.values(this._promises).forEach((e=>{e.cancel()})),!0}stop(){return this._paused=!0,Object.values(this._promises).forEach((e=>{e.resolve()})),!0}discard(){this.cancel(),delete this._promises}deactivate(){this.updateInternalWeight(0)}};const C=class TransitionState extends M{constructor(t={}){super(t),this._to=null,this._from=[],this._weightPromise=e.resolve()}get internalWeight(){let e=0;return this._to&&(e+=this._to.weight),this._from.forEach((t=>{e+=t.weight})),e*this._internalWeight}updateInternalWeight(e){super.updateInternalWeight(e),this._from.forEach((e=>{e.updateInternalWeight(this._internalWeight)})),this._to&&this._to.updateInternalWeight(this._internalWeight)}configure(e=[],t,i,s,n){(this._to===t||e.includes(this._to))&&(this._to=null),this._from=this._from.filter((i=>i!==t&&!e.includes(i))),this.deactivate(),this._from=e,this._to=t,this.reset(i,s,n)}reset(t,i,s){this._weightPromise.cancel();const n=this._from.map((e=>e.setWeight(0,t,i)));this._to?(n.push(this._to.setWeight(1,t,i)),this.name=this._to.name):this.name=null,this._weightPromise=e.all(n,(()=>{this._from.forEach((e=>{e.cancel(),e.deactivate()})),"function"==typeof s&&s()}))}play(t,i,s,n){this._paused=!1,this._playCallbacks.onFinish=t,this._playCallbacks.onError=i,this._playCallbacks.onCancel=s;const a=[this._weightPromise];return this._from.forEach((e=>{e.resume()})),this._to&&(this._promises.play=this._to.play(void 0,void 0,void 0,n),a.push(this._promises.play)),this._promises.finish=e.all(a,t,i,s),this._promises.finish}pause(){return this._from.forEach((e=>{e.pause()})),this._to&&this._to.pause(),super.pause()}resume(t,i,s,n){this._paused=!1,this._promises.play.pending||(this._playCallbacks.onFinish=t||this._playCallbacks.onFinish,this._playCallbacks.onError=i||this._playCallbacks.onError,this._playCallbacks.onCancel=s||this._playCallbacks.onCancel);const a=[this._weightPromise];return this._from.forEach((e=>{e.resume()})),this._to&&(this._promises.play=this._to.resume(void 0,void 0,void 0,n),a.push(this._promises.play)),this._promises.finish=e.all(a,this._playCallbacks.onFinish,this._playCallbacks.onError,this._playCallbacks.onCancel),this._promises.finish}cancel(){return this._from.forEach((e=>{e.pause()})),this._to&&this._to.cancel(),this._weightPromise.cancel(),super.cancel()}stop(){return this._from.forEach((e=>{e.pause()})),this._to&&this._to.stop(),super.stop()}update(e){super.update(e),this._from.forEach((t=>{t.update(e)})),this._to&&this._to.update(e)}discard(){super.discard(),this._weightPromise.cancel(),delete this._weightPromise,this._to=null,this._from.length=0}deactivate(){this._to&&this._to.deactivate(),this._from.forEach((e=>{e.deactivate()}))}};const I=class AnimationPlayerInterface{get paused(){return this._paused}get transitionTime(){}set transitionTime(e){}get easingFn(){}set easingFn(e){}get currentState(){}get currentAnimation(){}get isTransitioning(){}_prepareCurrentState(e,t,i,s,n){}playAnimation(e,t,i,s,n,a,r){}cancelAnimation(){}pauseAnimation(){}resumeAnimation(e,t,i,s,n,a,r){}stopAnimation(){}update(e){}discard(){}static Mixin(t=class{}){return class extends t{constructor(e={},...t){super(e,...t),this._transitionState=new C,this._states=void 0!==this._states?this._states:new Map,this._currentState=null,this._paused=!1,this._transitionTime=Number(e.transitionTime)>=0?Number(e.transitionTime):0,this._easingFn="function"==typeof e.easingFn?e.easingFn:void 0}get paused(){return this._paused}get transitionTime(){return this._transitionTime}set transitionTime(e){if(!((e=Number(e))>=0))throw new Error(`Cannot set transition time for ${this.constructor.name} to ${e}. Seconds must be a numeric value greather than or equal to zero.`);this._transitionTime=e}get easingFn(){return this._easingFn}set easingFn(e){this._easingFn=e}get currentState(){return this._currentState}get currentAnimation(){return this._currentState?this._currentState.name:null}get isTransitioning(){return this._currentState===this._transitionState}_prepareCurrentState(e,t,i,s,n){if(null!==e&&!this._states.has(e)){const i=new Error(`Cannot ${t} animation ${e}. No animation exists with this name.`);throw"function"==typeof n&&n(i),i}const a=null!==e?this._states.get(e):null;if(this.currentAnimation!==e)if(i<=0)this._currentState&&(this._currentState.cancel(),this._currentState.weight=0,this._currentState.deactivate()),this._currentState=a;else{const e=[...this._states.values()].filter((e=>e!==a&&(e.weight||e.weightPending)));this._transitionState.configure(e,a,i,s,(()=>{this._currentState=a,this._transitionState.weight=0})),this._currentState=this._transitionState}else"play"===t&&(this._currentState.cancel(),this._currentState===this._transitionState&&this._transitionState.reset(i,s,(()=>{this._currentState=a,this._transitionState.weight=0})));this._currentState.weight=1,this._currentState.updateInternalWeight(this._internalWeight)}playAnimation(t,i,s,n,a,r,o){let h,c=!1;try{this._prepareCurrentState(t,"play",void 0!==i?i:this._transitionTime,void 0!==s?s:this._easingFn,a)}catch(e){h=e,c=!0}return c?e.reject(h):this._currentState.play(n,a,r,o)}pauseAnimation(){return!!this._currentState&&this._currentState.pause()}resumeAnimation(t,i,s,n,a,r,o){let h;void 0===t&&this._currentState&&(t=this._currentState.name);let c=!1;try{this._prepareCurrentState(t,"resume",void 0!==i?i:this._transitionTime,void 0!==s?s:this._easingFn,a)}catch(e){h=e,c=!0}return c?e.reject(h):this._currentState.resume(n,a,r,o)}cancelAnimation(){return!!this._currentState&&this._currentState.cancel()}stopAnimation(){return!!this._currentState&&this._currentState.stop()}update(e){super.update&&super.update(e),this._currentState&&this._currentState.update(e)}discard(){super.discard&&super.discard(),this._transitionState.discard(),delete this._transitionState}}}};const P=class StateContainerInterface{getState(e){}getStateNames(){}addState(e){}removeState(e){}renameState(e,t){}discardStates(){}static Mixin(e=class{}){return class extends e{constructor(e={},...t){super(e,...t),this._states=void 0!==this._states?this._states:new Map}getState(e){return this._states.get(e)}getStateNames(){return[...this._states.keys()]}addState(e){if([...this._states.values()].includes(e))return console.warn(`Cannot add animation to state ${this.name}. Animation was already added.`),e.name;const i=t.getUniqueName(e.name,[...this._states.keys()]);return e.name!==i&&(console.warn(`Animation name ${e.name} is not unique for state ${this.name}. New animation will be added with name ${i}.`),e.name=i),this._states.set(e.name,e),e.name}removeState(e){return this._states&&this._states.has(e)?(this._states.get(e).discard(),this._states.delete(e),!0):(console.warn(`Did not remove animation ${e} from state ${this.name}. No animation exists with this name.`),!1)}renameState(e,i){if(!this._states||!this._states.has(e))throw new Error(`Cannot rename animation ${e} in ${this.name}. No animation exists with this name.`);const s=this._states.get(e);if(e===i)return e;const n=t.getUniqueName(i,[...this._states.keys()].filter((t=>t.name!==e)));return i!==n&&(console.warn(`Animation name ${i} is not unique in state ${this.name}. Animation will be renamed to ${n}.`),i=n),s.name=i,this._states.delete(e),this._states.set(s.name,s),s.name}discardStates(){this._states.forEach((e=>{e.discard()})),delete this._states}}}};class QueueState extends(I.Mixin(P.Mixin(M))){constructor(e={},t=[]){super(e),t.forEach((e=>{this.addState(e)})),this._queue=this._states.keys(),this._done=!0}get done(){return this._done}get internalWeight(){return this._currentState?this._currentState.internalWeight*this._internalWeight:0}_reset(){this._queue=this._states.keys();const{value:e,done:t}=this._queue.next();return this._done=t,e||null}updateInternalWeight(e){super.updateInternalWeight(e),this._currentState&&this._currentState.updateInternalWeight(this._internalWeight)}next(e,t=!1){const{value:i,done:s}=this._queue.next();if(this._done=s,this._paused=!1,s)return t?this.play(this._playCallbacks.onFinish,this._playCallbacks.onError,this._playCallbacks.onCancel,e):(this._promises.finish.resolve(),this._promises.finish);if("function"==typeof e){const t=i===[...this._states.keys()][this._states.size-1];e({name:i,canAdvance:this.getState(i).loopCount!==1/0&&!t,isQueueEnd:t})}return this.playAnimation(i,this._transitionTime,this._easingFn,(()=>{this._paused||this.isTransitioning||this.next(e)}),this._playCallbacks.onError),this._promises.finish}play(e,t,i,s){const n=this._reset();if(super.play(e,t,i),this._done)this._promises.finish.resolve();else{if(n!==this.currentAnimation&&"function"==typeof s){const e=n===[...this._states.keys()][this._states.size-1];s({name:n,canAdvance:!n||this.getState(n).loopCount!==1/0&&!e,isQueueEnd:!n||e})}this.playAnimation(n,this._currentState?this._transitionTime:0,this._easingFn,(()=>{this._paused||this.isTransitioning||this.next(s)}),t)}return this._promises.finish}pause(){const e=super.pause();return this.pauseAnimation(),e}resume(e,t,i,s){return this._done?this.play(e,t,i,s):(super.resume(e,t,i),this.resumeAnimation(this._currentState.name,this._transitionTime,this._easingFn,(()=>{this._paused||this.isTransitioning||this.next(s)}),t),this._promises.finish)}cancel(){const e=super.cancel();return this._currentState&&this._currentState.cancel(),e}stop(){const e=super.stop();return this.stopAnimation(),this._done=!0,e}discard(){super.discard(),this.discardStates()}}const $=QueueState;class AbstractBlendState extends(P.Mixin(M)){constructor(e={},t=[],...i){super(e,...i),t.forEach((e=>{this.addState(e)}))}get internalWeight(){let e=0;return this._states.forEach((t=>{e+=t.internalWeight})),e}getBlendWeight(e){const t=this.getState(e);if(void 0===t)throw new Error(`Cannot get weight of state ${e} from BlendState ${this.name}. No state exists with this name.`);return t.weight}setBlendWeight(e,t,i=0,s){const n=this.getState(e);if(void 0===n)throw new Error(`Cannot set weight of state ${e} from BlendState ${this.name}. No state exists with this name.`);return t=r.clamp(t),n.setWeight(t,i,s)}updateInternalWeight(e){super.updateInternalWeight(e),this._states.forEach((e=>{e.updateInternalWeight(this._internalWeight)}))}update(e){super.update(e),this._states.forEach((t=>{t.update(e)}))}play(t,i,s){const n=[super.play()];return this._states.forEach((e=>{n.push(e.play())})),e.all(n,t,i,s)}pause(){return this._states.forEach((e=>{e.pause()})),super.pause()}resume(t,i,s){const n=[super.resume()];return this._states.forEach((e=>{n.push(e.resume())})),e.all(n,t,i,s)}cancel(){return this._states.forEach((e=>{e.cancel()})),super.cancel()}stop(){return this._states.forEach((e=>{e.stop()})),super.stop()}discard(){super.discard(),this.discardStates()}}const V=AbstractBlendState;const R=class FreeBlendState extends V{constructor(e={},t=[]){super(e,t)}updateInternalWeight(e){super.updateInternalWeight(e);let t=0;this._states.forEach((e=>{t+=e.weight})),e/=Math.max(t,1),this._states.forEach((t=>{t.updateInternalWeight(e*this._weight)}))}};const W=class Blend1dState extends V{constructor(t={},i=[],s=[],n=[]){super(t,i),this._blendValue=0,this._promises={...this._promises,blendValue:e.resolve()};if(0!==i.length&&i.length!==s.length)throw new Error(`Cannot create Blend1dState with blendThresholds ${s}. BlendThresholds count does not match blendStates count.`);if(new Set(s).size!==s.length)throw new Error(`Cannot create Blend1dState with blendThresholds ${s}. BlendThresholds contains duplicate values`);this._thresholds=[],[...this._states.values()].forEach(((e,t)=>{this._thresholds.push({value:s[t],name:e.name,phaseMatch:n[t]||!1})})),this._sortThresholds(),this._forceNoThresholdDupes=!0,this._phaseLeadState=null,this._updateBlendWeights()}get blendValue(){return this._blendValue}set blendValue(e){this._blendValue=e}get blendValuePending(){return this._promises.blendValue&&this._promises.blendValue.pending}setBlendWeight(e,t,i=0,s){return this._promises.blendValue.cancel(),this._promises.blendValue=O.interpolateProperty(this,"blendValue",t,{seconds:i,easingFn:s,onProgress:()=>{this._updateBlendWeights()},onFinish:()=>{this._updateBlendWeights()}}),this._promises.blendValue}getBlendWeight(){return this.blendValue}addState(e,t=0,i=!1){this._thresholds=this._thresholds||[];const s=this._thresholds.find((e=>e.value===t));if(this._forceNoThresholdDupes&&void 0!==s)throw new Error(`Cannot set blend threshold of ${t} for state ${e.name} on ${this.name}. A state already exists with that threshold.`);return super.addState(e),this._thresholds.push({value:t,name:e.name,phaseMatch:i||!1}),this._sortThresholds(),e.name}removeState(e){const t=super.removeState(e);if(t){const t=this._thresholds.findIndex((t=>t.name===e));this._thresholds.splice(t,1)}return t}renameState(e,t){t=super.renameState(e,t);return this._thresholds.find((t=>t.name===e)).name=t,t}getBlendThreshold(e){const t=this._thresholds.find((t=>t.name===e));if(void 0===t)throw new Error(`Cannot get blend threshold of state ${e} on ${this.name}. No state exists with that name.`);return t.value}setBlendThreshold(e,t){const i=this._thresholds.find((e=>e.value===t));if(void 0!==i)throw new Error(`Cannot set blend threshold of ${t} for state ${e} on ${this.name}. A state already exists with that threshold.`);const s=this._thresholds.find((t=>t.name===e));if(void 0===s)throw new Error(`Cannot set blend threshold of state ${e} on ${this.name}. No state exists with that name.`);return s.value=t,this._sortThresholds(),s.value}updateInternalWeight(e){super.updateInternalWeight(e),this._phaseLeadState&&this._states.forEach((e=>{0!==e.weight&&(e.normalizedTime=this._phaseLeadState.normalizedTime)}))}_updateBlendWeights(){if(0===this._thresholds.length)return;if(1===this._thresholds.length){return void this._states.get(this._thresholds[0].name).setWeight(1)}this._states.forEach((e=>{e.setWeight(0)})),this._phaseLeadState=null;let e=this._thresholds.findIndex((e=>e.value>=this._blendValue));if(0===e||-1===e){e=-1===e?this._thresholds.length-1:0;this._states.get(this._thresholds[e].name).setWeight(1)}else{const t=this._thresholds[e-1],i=this._thresholds[e],s=(this.blendValue-t.value)/(i.value-t.value),n=1-s,a=this._states.get(t.name),r=this._states.get(i.name);a.setWeight(n),r.setWeight(s),t.phaseMatch&&i.phaseMatch&&(this._phaseLeadState=n>s?a:r)}}_sortThresholds(){this._thresholds.sort(((e,t)=>e.value-t.value))}};const j=class Blend2dState extends V{constructor(t={},i=[],s=[],n=[]){if(super(t,i),i.length!==s.length)throw new Error(`Cannot create Blend2dState with blendStates ${i} and blendThresholds ${s}. Count of blendStates must match count of blendThresholds.`);s.slice(0,s.length-1).forEach(((e,t)=>{s.slice(t+1).forEach((t=>{if(e[0]===t[0]&&e[1]===t[1])throw new Error(`Cannot create Blend2dState with blendThresholds ${s}. No duplicate values allowed in blendThresholds.`)}))})),this._blendValueX=0,this._blendValueY=0,this._promises={...this._promises,blendValueX:e.resolve(),blendValueY:e.resolve()},this._thresholds=[],[...this._states.values()].forEach(((e,t)=>{this._thresholds.push({name:e.name,phaseMatch:n[t]||!1})})),this._vertices=s,this._vertices.length>=3&&(this._triangles=r.getDelaunayTriangulation(this._vertices)),this._phaseLeadState=null,this._updateBlendWeights()}setBlendWeight(e,t,i=0,s){const n=`blendValue${e.toUpperCase()}`;if("blendValueX"!==n&&"blendValueY"!==n)throw new Error(`Cannot set blend weight for ${e} on ${this.name}. Blend2dState only accepts 'X' or 'Y' for setBlendWeight`);return this._promises[n].cancel(),this._promises[n]=O.interpolateProperty(this,n,t,{seconds:i,easingFn:s,onProgress:()=>{this._updateBlendWeights()},onFinish:()=>{this._updateBlendWeights()}}),this._promises[n]}getBlendWeight(e){const t=e.toUpperCase();if("X"!==t&&"Y"!==t)throw new Error(`Cannot get blend weight for ${e} on ${this.name}. Blend2dState only accepts 'X' or 'Y' for getBlendWeight`);return"X"===t?this._blendValueX:this._blendValueY}get blendValueX(){return this._blendValueX}set blendValueX(e){this._blendValueX=e}get blendValueY(){return this._blendValueY}set blendValueY(e){this._blendValueY=e}get blendValueXPending(){return this._promises.blendValueX&&this._promises.blendValueX.pending}get blendValueYPending(){return this._promises.blendValueY&&this._promises.blendValueY.pending}updateInternalWeight(e){super.updateInternalWeight(e),this._phaseLeadState&&[...this._states.values()].forEach(((e,t)=>{0!==e.weight&&this._thresholds[t].phaseMatch&&(e.normalizedTime=this._phaseLeadState.normalizedTime)}))}_updateBlendWeights(){if(!this._vertices||0===this._vertices.length)return;if(1===this._vertices.length)return void([...this._states.values()][0].weight=1);this._states.forEach((e=>{e.setWeight(0)})),this._phaseLeadState=null;const e=[this._blendValueX,this._blendValueY];if(2===this._vertices.length)this._setInfluenceClosestPointOnLine(e);else{const t=this._triangles.find((t=>r.isPointInTriangle(this._vertices[t[0]],this._vertices[t[1]],this._vertices[t[2]],e)));t?this._setInfluenceTriangle(t,e):this._setInfluenceClosestPointInTriangles(e)}}_setInfluenceTriangle(e,t){const i=r.triangleArea(this._vertices[e[1]],this._vertices[e[2]],t),s=r.triangleArea(this._vertices[e[0]],this._vertices[e[2]],t),n=r.triangleArea(this._vertices[e[0]],this._vertices[e[1]],t),a=i+s+n,o=i/a,h=s/a,c=n/a,l=this._thresholds[e[0]],u=this._thresholds[e[1]],d=this._thresholds[e[2]],m=this._states.get(l.name),_=this._states.get(u.name),p=this._states.get(d.name);m.setWeight(o),_.setWeight(h),p.setWeight(c),this._setPhaseLeadState([m,_,p],[l.phaseMatch,u.phaseMatch,d.phaseMatch])}_setInfluenceClosestPointInTriangles(e){let t=null,i=Number.POSITIVE_INFINITY,s=-1;this._triangles.forEach(((n,a)=>{const o=r.closestPointOnLine(this._vertices[n[0]],this._vertices[n[1]],e),h=r.closestPointOnLine(this._vertices[n[1]],this._vertices[n[2]],e),c=r.closestPointOnLine(this._vertices[n[2]],this._vertices[n[0]],e),l=r.distanceSquared(o,e),u=r.distanceSquared(h,e);let d=c,m=r.distanceSquared(c,e);l<m&&(d=o,m=l),u<m&&(d=h,m=u),m<i&&(i=m,t=[...d],s=a)})),this._setInfluenceTriangle(this._triangles[s],t)}_setInfluenceClosestPointOnLine(e){const t=r.closestPointOnLine(this._vertices[[0]],this._vertices[[1]],e),i=r.distanceSquared(this._vertices[0],t),s=r.distanceSquared(this._vertices[1],t),n=s/(i+s),a=i/(i+s),o=this._thresholds[0],h=this._thresholds[1],c=this._states.get(o.name),l=this._states.get(h.name);c.setWeight(n),l.setWeight(a),this._setPhaseLeadState([c,l],[o.phaseMatch,h.phaseMatch])}_setPhaseLeadState(e,t){let i=0;e.forEach(((e,s)=>{t[s]&&e.weight>i&&(this._phaseLeadState=e,i=e.weight)}))}},D={Override:"Override",Additive:"Additive"},B="Override";class AnimationLayer extends(I.Mixin(P.Mixin())){constructor(t={}){super(t),this.name=void 0===t.name?"AnimationLayer":t.name,this._blendMode=Array.from(Object.values(D)).includes(t.blendMode)?t.blendMode:B,this._promises={weight:e.resolve()},this._weightPaused=!1,this.weight="number"==typeof t.weight?t.weight:1,this._internalWeight=this._weight}get blendMode(){return this._blendMode}set weight(e){this._weight=r.clamp(e,0,1)}get weight(){return this._weight}get weightPending(){return this._promises.weight&&this._promises.weight.pending}pause(){return this._paused=!0,this._weightPaused=!0,this.pauseAnimation()||this.weightPending}resume(){this._paused=!1,this._weightPaused=!1;const e=this.weightPending;return this._currentState&&this.resumeAnimation()||e}setWeight(e,t=0,i){return this.weightPending&&this._promises.weight.cancel(),e=r.clamp(e),this._promises.weight=O.interpolateProperty(this,"weight",e,{seconds:t,easingFn:void 0!==i?i:this._easingFn}),this._promises.weight}pauseWeight(){return this._weightPaused=!0,this.weightPending}resumeWeight(){return this._weightPaused=!1,this.weightPending}updateInternalWeight(e){this._internalWeight=this._weight*e,this._currentState&&this._currentState.updateInternalWeight(this._internalWeight)}getAnimationBlendNames(e){const t=this.getState(e);if(void 0===t)throw new Error(`Cannot get blend names of animation ${e} on layer ${this.name}. No animation exists with this name.`);if(t instanceof V)return t.getStateNames();throw new Error(`Cannot get blend names of animation ${e} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`)}setAnimationBlendWeight(e,t,i,s=0,n){const a=this.getState(e);if(void 0===a)throw new Error(`Cannot set blend weight of animation ${e} on layer ${this.name}. No animation exists with this name.`);if(a instanceof V)return a.setBlendWeight(t,i,s,n);throw new Error(`Cannot set blend weight of animation ${e} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`)}getAnimationBlendWeight(e,t){const i=this.getState(e);if(void 0===i)throw new Error(`Cannot get blend weight of animation ${e} on layer ${this.name}. No animation exists with this name.`);if(i instanceof V)return i.getBlendWeight(t);throw new Error(`Cannot get blend weight of animation ${e} on layer ${this.name}. Animation is not an instance of AbstractBlendState.`)}update(e){super.update(e),this._paused||this._weightPaused||this._promises.weight.execute(e)}discard(){super.discard(),this.discardStates(),this._promises.weight.cancel(),delete this._promises}}const U=AnimationLayer;const G=class SingleState extends M{constructor(t={}){var i;super(t),this._timeScale=void 0!==t.timeScale?t.timeScale:1,this._promises.timeScale=e.resolve(),this._loopCount=void 0!==t.loopCount?t.loopCount:1/0,this._blendMode=(i=t.blendMode,Array.from(Object.values(D)).includes(i)?i:B)}get normalizedTime(){return 0}get timeScale(){return this._timeScale}set timeScale(e){this._timeScale=e}get timeScalePending(){return this._promises.timeScale.pending}setTimeScale(e,t=0,i){return this._promises.timeScale.cancel(),this._promises.timeScale=O.interpolateProperty(this,"timeScale",e,{seconds:t,easingFn:i}),this._promises.timeScale}get loopCount(){return this._loopCount}set loopCount(e){this._loopCount=e}get blendMode(){return this._blendMode}};class RandomAnimationState extends(I.Mixin(P.Mixin(M))){constructor(e={},t=[]){super(e),this._playInterval=e.playInterval?e.playInterval:3,t.forEach((e=>{this.addState(e)}))}get playInterval(){return this._playInterval}set playInterval(e){this._playInterval=e}_resetTimer(){const e=t.getRandomFloat(this._playInterval/4,2*this._playInterval);this._promises.timer=t.wait(e,{onFinish:()=>{this.playRandomAnimation(this._playCallbacks.onError)}})}updateInternalWeight(e){super.updateInternalWeight(e),this._currentState&&this._currentState.updateInternalWeight(this._internalWeight)}playRandomAnimation(e){this._resetTimer();const i=this.getStateNames();this._currentState&&i.splice(i.indexOf(this._currentState.name),1);const s=i[t.getRandomInt(0,i.length)];this.playAnimation(s,this._transitionTime,this._easingFn,void 0,e,void 0)}play(e,t,i){return this.playRandomAnimation(t),super.play(e,t,i)}pause(){return super.pause()&&this.pauseAnimation()}resume(e,t,i){return this._currentState&&this.resumeAnimation(this._currentState.name,this._transitionTime,this._easingFn,void 0,t,void 0),super.resume(e,t,i)}cancel(){return super.cancel()&&this.cancelAnimation()}stop(){return super.stop()&&this.stopAnimation()}discard(){super.discard(),this.discardStates()}}const Y=RandomAnimationState,z={single:G,freeBlend:R,queue:$,randomAnimation:Y,blend1d:W,blend2d:j};class AnimationFeature extends c{constructor(e){super(e),this._layers=[],this._layerMap={},this._paused=!1}_validateIndex(e,t=!0){if(0===this._layers.length&&t)return;const i=t?this._layers.length-1:this._layers.length;return e<0&&(e=i+e+1),e<0||e>i?void 0:e}_updateInternalWeights(){let e=1;for(let t=this._layers.length-1;t>=0;t--){const i=this._layers[t];i.updateInternalWeight(e),i.blendMode===D.Override&&i.currentState&&(e*=1-i.currentState.internalWeight)}}_createSingleState(e){return new G(e)}_createFreeBlendState(e){const{blendStateOptions:t=[]}=e,i=[];return t.forEach((t=>{i.push(this._createSingleState({...t,blendMode:e.blendMode}))})),new R(e,i)}_createQueueState(e){const{queueOptions:t=[]}=e,i=t.map((t=>this._createSingleState({transitionTime:e.transitionTime,...t,blendMode:e.blendMode})));return new $(e,i)}_createBlend1dState(e){const{blendStateOptions:t=[]}=e,{blendThresholds:i=[]}=e,{blendMatchPhases:s=[]}=e,n=[];return t.forEach((t=>{n.push(this._createSingleState({...t,blendMode:e.blendMode}))})),new W(e,n,i,s)}_createBlend2dState(e){const{blendStateOptions:t=[]}=e,{blendThresholds:i=[]}=e,{blendMatchPhases:s=[]}=e,n=[];return t.forEach((t=>{n.push(this._createSingleState({...t,blendMode:e.blendMode}))})),new j(e,n,i,s)}_createRandomAnimationState(e){const{subStateOptions:t=[]}=e,i=[];return t.forEach((t=>{i.push(this._createSingleState({...t,blendMode:e.blendMode}))})),new Y(e,i)}_validateNewAnimation(e,i){const s=this._layerMap[e];if(void 0===s)throw new Error(`Cannot add animation to layer ${e} from host ${this._host.id}. No layer exists with this name.`);const n=t.getUniqueName(i,s.getStateNames());return n!==i&&console.warn(`Animation name ${i} is not unique for layer ${s.name}. Animation will be renamed to ${n}.`),n}get paused(){return this._paused}get layers(){return this._layers.map((e=>e.name))}addLayer(e="NewLayer",i={},s){const n=this._layers.length;let a=s;void 0===s||-1===s?a=this._layers.length:(a=this._validateIndex(s,!1),void 0===a&&(a=s<0?0:this._layers.length,console.warn(`Index ${s} is invalid for host ${this._host.id}. New layer will be added at the closest valid index: ${a}.`)));const r=t.getUniqueName(e,Object.keys(this._layerMap));e!==r&&console.warn(`Layer name ${e} is not unique. New layer will be added with the name ${r}.`);const o=new U({...i,name:r});this._layerMap[r]=o,a===n?this._layers.push(o):this._layers.splice(a,0,o);const h={name:r,index:a};return this.emit(this.constructor.EVENTS.addLayer,h),h}removeLayer(e){const t=this._layerMap[e];if(void 0===t)return console.warn(`Did not remove layer ${e} from host ${this._host.id}. No layer exists with this name.`),!1;t.discard();const i=this._layers.indexOf(t);return this._layers.splice(i,1),delete this._layerMap[e],this.emit(this.constructor.EVENTS.removeLayer,{name:e,index:i}),!0}moveLayer(e,t){const i=this._layerMap[e];if(void 0===i)throw new Error(`Cannot move layer ${e} from host ${this._host.id}. No layer exists with this name.`);const s=this._validateIndex(t,!0),n=this._layers.length-1;if(void 0===s)throw new Error(`Cannot move layer ${e} from host ${this._host.id} to index ${t}. Index must be in the 0 - ${n} range.`);const a=this._layers.indexOf(i);if(a!==s)return this._layers.splice(a,1),s===n?this._layers.push(i):this._layers.splice(s,0,i),s}renameLayer(e,i){const s=this._layerMap[e];if(void 0===s)throw new Error(`Cannot rename layer ${e} from host ${this._host.id}. No layer exists with this name.`);const n=t.getUniqueName(i,Object.keys(this._layerMap));return n!==i&&console.warn(`Layer name ${i} is not unique. Layer will be renamed to ${n}.`),delete this._layerMap[e],this._layerMap[n]=s,s.name=n,this.emit(this.constructor.EVENTS.renameLayer,{oldName:e,newName:n}),n}getLayerWeight(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Cannot get weight on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.weight}setLayerWeight(t,i,s,n){const a=this._layerMap[t];if(void 0===a){const i=`Cannot set weight on layer ${t} from host ${this._host.id}. No layer exists with this name.`;return e.reject(i)}return a.setWeight(i,s,n)}getAnimationBlendNames(e,t){const i=this._layerMap[e];if(void 0===i)throw new Error(`Cannot get blend names on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return i.getAnimationBlendNames(t)}setAnimationBlendWeight(t,i,s,n,a,r){const o=this._layerMap[t];if(void 0===o){const i=`Cannot set blend weight on layer ${t} from host ${this._host.id}. No layer exists with this name.`;return e.reject(i)}return o.setAnimationBlendWeight(i,s,n,a,r)}getAnimationBlendWeight(e,t,i){const s=this._layerMap[e];if(void 0===s)throw new Error(`Cannot get blend weight on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return s.getAnimationBlendWeight(t,i)}pauseLayerWeight(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Cannot pause weight interpolation on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.pauseWeight()}resumeLayerWeight(t){const i=this._layerMap[t];if(void 0===i){const i=`Cannot resume weight interpolation on layer ${t} from host ${this._host.id}. No layer exists with this name.`;return e.reject(i)}return i.resumeWeight()}pauseLayer(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Cannot pause layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.pause()}resumeLayer(t){const i=this._layerMap[t];if(void 0===i){const i=`Cannot resume layer ${t} from host ${this._host.id}. No layer exists with this name.`;return e.reject(i)}return i.resume()}getTransitioning(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Get transitioning on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.isTransitioning}getAnimations(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Get animations on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.getStateNames()}getCurrentAnimation(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Get current animation on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.currentAnimation}getPaused(e){const t=this._layerMap[e];if(void 0===t)throw new Error(`Get paused on layer ${e} from host ${this._host.id}. No layer exists with this name.`);return t.currentState&&t.currentState.paused}getAnimationType(e,t){const i=this._layerMap[e];if(void 0===i)throw new Error(`Get animation type on layer ${e} from host ${this._host.id}. No layer exists with this name.`);const s=i.getState(t);if(void 0===s)throw new Error(`Get animation type for animation ${t} on layer ${e} from host ${this._host.id}. No animation exists with this name.`);const{constructor:n}=s;return Object.keys(z).find((e=>z[e]===n))}addAnimation(e,t,i=z.single,s={}){if(s.name=this._validateNewAnimation(e,t),!Object.values(z).includes(i))throw new Error(`Cannot add animation ${t} to layer ${e} on host ${this._host.id}. Invalid animation type.`);const n=this._layerMap[e];s.blendMode=n.blendMode,s.transitionTime=n.transitionTime;const a=this[`_create${i.name}`](s),r=n.addState(a);return this.emit(this.constructor.EVENTS.addAnimation,{layerName:e,animationName:r}),r}removeAnimation(e,t){const i=this._layerMap[e];if(void 0===i)throw new Error(`Cannot remove animation from layer ${e} from host ${this._host.id}. No layer exists with this name.`);const s=i.removeState(t);return!0===s&&this.emit(this.constructor.EVENTS.removeAnimation,{layerName:e,animationName:t}),s}renameAnimation(e,t,i){const s=this._layerMap[e];if(void 0===s)throw new Error(`Cannot rename animation ${t} on layer ${e} for host ${this._host.id}. No layer exists with this name.`);const n=s.renameState(t,i);return this.emit(this.constructor.EVENTS.renameAnimation,{layerName:e,oldName:t,newName:n}),n}playAnimation(t,i,s,n){const a=this._layerMap[t];if(void 0===a){const s=`Cannot play animation ${i} on layer ${t} for host ${this._host.id}. No layer exists with this name.`;return e.reject(s)}return this.emit(this.constructor.EVENTS.playAnimation,{layerName:t,animationName:i}),a.playAnimation(i,s,n,(()=>{this.emit(this.constructor.EVENTS.stopAnimation,{layerName:t,animationName:i})}),void 0,(()=>{this.emit(this.constructor.EVENTS.interruptAnimation,{layerName:t,animationName:i})}),(({name:e,canAdvance:s,isQueueEnd:n})=>{a.currentAnimation===i&&this.emit(this.constructor.EVENTS.playNextAnimation,{layerName:t,animationName:i,nextQueuedAnimation:e,canAdvance:s,isQueueEnd:n})}))}playNextAnimation(t,i,s,n){const a=this._layerMap[t];if(void 0===a){const i=`Cannot play next animation on layer ${t} for host ${this._host.id}. No layer exists with this name.`;return e.reject(i)}void 0===i&&(i=a.currentAnimation);const r=a.getState(a.currentAnimation);if(null===r){const s=`Cannot play next animation on layer ${t} for host ${this._host.id}. No animation exists with name ${i}.`;return e.reject(s)}if("queue"!==this.getAnimationType(t,i)){const s=`Cannot play next animation on layer ${t} for host ${this._host.id}. ${i} is not a queue state.`;return e.reject(s)}const o=({name:e,canAdvance:s,isQueueEnd:n})=>{a.currentAnimation===i&&this.emit(this.constructor.EVENTS.playNextAnimation,{layerName:t,animationName:i,nextQueuedAnimation:e,canAdvance:s,isQueueEnd:n})};return null===a.currentAnimation&&a.resumeAnimation(r.name,s,n,void 0,void 0,void 0,o),r.next(o,!0)}pauseAnimation(e){const t=this._layerMap[e];if(void 0===t)return console.warn(`Did not pause animation on layer ${e} for host ${this._host.id}. No layer exists with this name.`),!1;const i=t.pauseAnimation();if(i){const i=t.currentAnimation;this.emit(this.constructor.EVENTS.pauseAnimation,{layerName:e,animationName:i})}return i}resumeAnimation(t,i,s,n){const a=this._layerMap[t];if(void 0===a){const s=`Cannot resume animation ${i} on layer ${t} for host ${this._host.id}. No layer exists with this name.`;return e.reject(s)}return this.emit(this.constructor.EVENTS.resumeAnimation,{layerName:t,animationName:i}),a.resumeAnimation(i,s,n,(()=>{this.emit(this.constructor.EVENTS.stopAnimation,{layerName:t,animationName:i})}),void 0,(()=>{this.emit(this.constructor.EVENTS.interruptAnimation,{layerName:t,animationName:i})}),(({name:e,canAdvance:s,isQueueEnd:n})=>{a.currentAnimation===i&&this.emit(this.constructor.EVENTS.playNextAnimation,{layerName:t,animationName:i,nextQueuedAnimation:e,canAdvance:s,isQueueEnd:n})}))}stopAnimation(e){const t=this._layerMap[e];return void 0===t?(console.warn(`Did not stop animation on layer ${e} for host ${this._host.id}. No layer exists with this name.`),!1):t.stopAnimation()}pause(){this._paused=!0;let e=!1;return this._layers.forEach((t=>{t.pause()&&(e=!0)})),e}resume(){this._paused=!1;let e=!1;return this._layers.forEach((t=>{t.resume()&&(e=!0)})),e}installApi(){const e=super.installApi();Object.defineProperties(e,{paused:{get:()=>this.paused},layers:{get:()=>this.layers}}),Object.assign(e,{addLayer:this.addLayer.bind(this),removeLayer:this.removeLayer.bind(this),moveLayer:this.moveLayer.bind(this),renameLayer:this.renameLayer.bind(this),getLayerWeight:this.getLayerWeight.bind(this),setLayerWeight:this.setLayerWeight.bind(this),pauseLayerWeight:this.pauseLayerWeight.bind(this),resumeLayerWeight:this.resumeLayerWeight.bind(this),pauseLayer:this.pauseLayer.bind(this),resumeLayer:this.resumeLayer.bind(this),getTransitioning:this.getTransitioning.bind(this),getAnimations:this.getAnimations.bind(this),getCurrentAnimation:this.getCurrentAnimation.bind(this),getPaused:this.getPaused.bind(this),getAnimationType:this.getAnimationType.bind(this),addAnimation:this.addAnimation.bind(this),removeAnimation:this.removeAnimation.bind(this),renameAnimation:this.renameAnimation.bind(this),getAnimationBlendNames:this.getAnimationBlendNames.bind(this),getAnimationBlendWeight:this.getAnimationBlendWeight.bind(this),setAnimationBlendWeight:this.setAnimationBlendWeight.bind(this),playAnimation:this.playAnimation.bind(this),playNextAnimation:this.playNextAnimation.bind(this),pauseAnimation:this.pauseAnimation.bind(this),resumeAnimation:this.resumeAnimation.bind(this),stopAnimation:this.stopAnimation.bind(this),pause:this.pause.bind(this),resume:this.resume.bind(this)})}update(e){this._layers.length&&(this._paused&&(e=0),this._updateInternalWeights(),this._layers.forEach((t=>{t.update(e)})),super.update(e))}discard(){this._layers.forEach((e=>{e.discard()})),delete this._layers,delete this._layerMap,super.discard()}}Object.defineProperty(AnimationFeature,"EVENTS",{value:{...Object.getPrototypeOf(c).EVENTS,addLayer:"onAddLayerEvent",removeLayer:"onRemoveLayerEvent",renameLayer:"onRenameLayerEvent",addAnimation:"onAddAnimationEvent",removeAnimation:"onRemovedAnimationEvent",renameAnimation:"onRenameAnimationEvent",playAnimation:"onPlayEvent",playNextAnimation:"onNextEvent",pauseAnimation:"onPauseEvent",resumeAnimation:"onResumeEvent",interruptAnimation:"onInterruptEvent",stopAnimation:"onStopEvent"}});const q=AnimationFeature,X={PositiveX:[1,0,0],NegativeX:[-1,0,0],PositiveY:[0,1,0],NegativeY:[0,-1,0],PositiveZ:[0,0,1],NegativeZ:[0,0,-1]},H=0,Q=1,J=2,Z=3,K=[[0,0,0],[-.032,0,0],[.032,0,0],[0,-.064,0]],ee={default:[.8,1.75],postMacro:[.6,1.3125]},te={default:[5,8],mouthTarget:[.2,.75],eyeTarget:[1.5,4]};class PointOfInterestFeature extends(c.mix(x.Mixin,w.Mixin)){constructor(e,{target:t,lookTracker:i,scene:s}={},{blendTime:n=.1,easingFn:a=d.InOut,layers:r=[]}={},{blendTime:o=.075,easingFn:h=d.InOut,layers:c=[]}={}){if(super(e),!this.constructor._validateTransformObject(i))throw new Error(`Cannot initialize PointOfInterestFeature on host ${this._host.id}. LookTracker must be defined as a valid transformation object.`);this._lookTracker=i,this._scene=s,this._target=t||null,this._prevTargetPos=[0,0,0],this._isTargetMoving=!1,this._lookLayers=this._lookLayers||{},this._trackingConfigs=this._trackingConfigs||[],this._blinkLayers=this._blinkLayers||{},r.forEach((({name:e,animation:t,maxSpeed:i,reference:s,forwardAxis:r,hasSaccade:o,blendTime:h,easingFn:c})=>{this.registerLookLayer(e,{animation:t,maxSpeed:i,reference:s,forwardAxis:r,hasSaccade:o,blendTime:void 0!==h?h:n,easingFn:void 0!==c?c:a})})),c.forEach((({name:e,animation:t,blendTime:i,easingFn:s})=>{this.registerBlinkLayer(e,{animation:t,blendTime:void 0!==i?i:o,easingFn:void 0!==s?s:h})}))}get target(){return this._target}set target(e){this._target=e||null}static _getWorldPosition(e){return[0,0,0]}static _getWorldMatrix(e){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}static _getObjectDirection(e,t=X.PositiveZ){const i=r.getRotationMatrix(this._getWorldMatrix(e));return r.rotateVector(t,i)}static _sphericalToBlendValue(e,t){return{h:r.toDegrees(t),v:r.toDegrees(e)-90}}_onLayerAdded({name:e}){this._lookLayers=this._lookLayers||{},this._blinkLayers=this._blinkLayers||{},super._onLayerAdded({name:e}),void 0!==this._lookLayers[e]&&this._registerLookAnimation(e,this._lookLayers[e])}_onAnimationAdded({layerName:e,animationName:t}){this._lookLayers=this._lookLayers||{},this._blinkLayers=this._blinkLayers||{},super._onAnimationAdded({layerName:e}),this._lookLayers[e]===t&&this._registerLookAnimation(e,t)}_registerLookAnimation(e,t){this._managedLayers[e].animations[t].isActive&&z[this._host.AnimationFeature.getAnimationType(e,t)]!==z.blend2d&&(console.warn(`Cannot register Point of Interest look animation ${t} on layer ${e} for host ${this._host.id}. Look animations must be of type 'blend2d'.`),this._managedLayers[e].animations[t].isActive=!1)}static _validateTransformObject(e){return e instanceof Object}_addTrackingConfig(e){const t=this._trackingConfigs.find((t=>t.reference===e.reference&&t.forwardAxis===e.forwardAxis));return t||(e.angles={h:0,v:0},e.prevAngles={h:0,v:0},this._trackingConfigs.push(e),e)}_getTargetDistance(){const e=this.constructor._getWorldPosition(this._lookTracker),t=this.constructor._getWorldPosition(this._target),i=[t[0]-e[0],t[1]-e[1],t[2]-e[2]];return r.getVectorMagnitude(i)}_resetLookAngles(){this._trackingConfigs.forEach((({angles:e})=>{e.h=0,e.v=0}))}_setLookAngles(){const e=this.constructor._getWorldPosition(this._target),t=this.constructor._getWorldPosition(this._lookTracker);this._isTargetMoving=r.getVectorMagnitude([e[0]-this._prevTargetPos[0],e[1]-this._prevTargetPos[1],e[2]-this._prevTargetPos[2]])>0,Object.assign(this._prevTargetPos,e);const i=r.cartesianToSpherical(e[0]-t[0],e[1]-t[1],e[2]-t[2]),s=this.constructor._sphericalToBlendValue(i[1],i[2]);this._trackingConfigs.forEach((({reference:e,forwardAxis:t,angles:i})=>{const n=this.constructor._getObjectDirection(e,t),a=r.cartesianToSpherical(...n),o=this.constructor._sphericalToBlendValue(a[1],a[2]);i.h=s.h-o.h,i.v=s.v-o.v}))}_getFaceTargetAngles(e){if(0===e)return{h:0,v:0};const t=this._getTargetDistance(this._lookTracker),i=[...K[e]];i[2]=t;const s=r.cartesianToSpherical(...i),n=this.constructor._sphericalToBlendValue(s[1],s[2]);return n.h=r.clamp(n.h,-35,35),n.v=r.clamp(n.v,-25,30),n}_updateLayerSpeed(e,t,i){const s=this._managedLayers[e];s.maxHSpeed=473*(1-Math.exp(-t/7.8)),s.maxVSpeed=473*(1-Math.exp(-i/7.8));const n=.00235;s.hDuration=.025+n*t,s.vDuration=.025+n*i}_setMicroSaccade(e){const i=this._managedLayers[e],{microSaccade:s}=i;this._target?(s.h=t.getRandomFloat(.01,.15),s.v=t.getRandomFloat(.01,.15)):(s.h=t.getRandomFloat(.01,.3),s.v=t.getRandomFloat(.01,.3)),this._updateLayerSpeed(e,s.h,s.v),this._initializeMicroTimer(e,...ee.default)}_setMacroSaccade(e){const i=this._managedLayers[e],{macroSaccade:s}=i;let n;if(this._target){switch(i.saccadeTarget){case 1:n=te.eyeTarget,i.saccadeTarget=Math.random()<.75?J:Z;break;case 2:n=te.eyeTarget,i.saccadeTarget=Math.random()<.75?Q:Z;break;case 3:n=te.mouthTarget,i.saccadeTarget=Math.random()<.5?Q:J;break;default:n=te.eyeTarget,i.saccadeTarget=Math.random()<.5?Q:J}const{h:e,v:t}=this._getFaceTargetAngles(i.saccadeTarget);s.h=e,s.v=t}else{n=te.default;const e=t.getRandomFloat(.143,.286),i=t.getRandomFloat(-e,e);s.h=35*i;const a=t.getRandomFloat(.093,.186),r=t.getRandomFloat(-a,a);s.v=r>0?25*r:30*r}this._updateLayerSpeed(e,s.h,s.v),this._initializeMicroTimer(e,...ee.postMacro),this._initializeMacroTimer(e,...n)}_initializeMicroTimer(e,i,s){const n=this._managedLayers[e],a=t.getRandomFloat(i,s);n.microSaccadeTimer&&n.microSaccadeTimer.cancel(),n.microSaccadeTimer=t.wait(a,{onFinish:()=>{this._setMicroSaccade(e)}})}_initializeMacroTimer(e,i,s){const n=this._managedLayers[e],a=t.getRandomFloat(i,s);n.macroSaccadeTimer&&n.macroSaccadeTimer.cancel(),n.macroSaccadeTimer=t.wait(a,{onFinish:()=>{this._setMacroSaccade(e)}})}setTarget(e){this.target=e}setTargetByName(e){if(e||(this._target=null),!this._scene)throw new Error(`Cannot set PointOfInterestFeature target using name ${e} on host ${this._host.id}. Scene must be defined.`)}setTargetById(e){if(e||(this._target=null),!this._scene)throw new Error(`Cannot set PointOfInterestFeature target using id ${e} on host ${this._host.id}. Scene must be defined.`)}registerLookLayer(e,{animation:t="look",maxSpeed:i=25,reference:s,forwardAxis:n="PositiveZ",hasSaccade:a=!1,blendTime:r=PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime,easingFn:o}={}){if(s=s||this._host.owner,!this.constructor._validateTransformObject(s))throw new Error(`Cannot initialize register look layer ${e} for PointOfInterestFeature on host ${this._host.id}. Reference must be defined as a valid transformation object.`);n=void 0!==X[n]?X[n]:X.PositiveZ;const h=this._addTrackingConfig({reference:s,forwardAxis:n});if(this.registerLayer(e,{trackingConfig:h,maxSpeed:i,maxHSpeed:void 0,maxVSpeed:void 0,hDuration:void 0,vDuration:void 0,hVelocity:[0,0],vVelocity:[0,0],hasSaccade:a,blendTime:r,easingFn:o,microSaccade:{h:0,v:0},macroSaccade:{h:0,v:0},saccadeTarget:H,animations:{[t]:{}}}),this._lookLayers[e]=t,this._registerLookAnimation(e,t),a){const t=this._target?te.eyeTarget:te.default;this._initializeMicroTimer(e,...ee.default),this._initializeMacroTimer(e,...t)}}registerBlinkLayer(e,{animation:t="blink",blendTime:i=PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime,easingFn:s}={}){this.registerLayer(e,{blendTime:i,easingFn:s,animations:{[t]:{}}}),this._blinkLayers[e]=t}update(e){super.update(e),this._target?this._setLookAngles():this._resetLookAngles();const t=Math.min(e,33.333333333333336)/1e3;let i=!1;Object.entries(this._lookLayers).forEach((([s,n])=>{const a=this._managedLayers[s];if(a.isActive&&a.hasSaccade&&(a.microSaccadeTimer.execute(e),a.macroSaccadeTimer.execute(e)),a.animations[n].isActive){const e=this._host.AnimationFeature.getAnimationBlendWeight(s,n,"X"),o=this._host.AnimationFeature.getAnimationBlendWeight(s,n,"Y");let h=a.trackingConfig.angles.h,c=a.trackingConfig.angles.v;if(this._isTargetMoving&&!i){const e=a.trackingConfig.prevAngles.h,t=a.trackingConfig.prevAngles.v;r.toDegrees(r.getAngleBetween([e,t],[h,c]))>=35&&(i=!0)}a.trackingConfig.prevAngles.h=h,a.trackingConfig.prevAngles.v=c,a.hasSaccade&&(r.dampValue(0,a.macroSaccade.h+a.macroSaccade.h,a.hVelocity,a.hDuration,a.maxHSpeed),h+=a.hVelocity[0],r.dampValue(0,a.macroSaccade.v+a.macroSaccade.v,a.vVelocity,a.vDuration,a.maxVSpeed),c+=a.vVelocity[0]);const l=r.clamp(t*a.maxSpeed,0,1);h=r.lerp(e,h,l),c=r.lerp(o,c,l),this._host.AnimationFeature.setAnimationBlendWeight(s,n,"X",h),this._host.AnimationFeature.setAnimationBlendWeight(s,n,"Y",c)}})),i&&this._isTargetMoving&&Object.entries(this._blinkLayers).forEach((([e,t])=>{this._managedLayers[e].animations[t].isActive&&this._host.AnimationFeature.playAnimation(e,t)}))}installApi(){const e=super.installApi();return Object.defineProperties(e,{target:{get:()=>this.target,set:e=>{this.target=e}}}),Object.assign(e,{registerLookLayer:this.registerLookLayer.bind(this),registerBlinkLayer:this.registerBlinkLayer.bind(this),setTarget:this.setTarget.bind(this),setTargetByName:this.setTargetByName.bind(this),setTargetById:this.setTargetById.bind(this)}),e}}const ie=PointOfInterestFeature,se={AnimationFeature:q,AnimationLayer:U,SingleState:G,TransitionState:C,FreeBlendState:R,QueueState:$,RandomAnimationState:Y,Blend1dState:W,Blend2dState:j,AnimationUtils:O,Easing:{Linear:u,Quadratic:d,Cubic:m,Quartic:_,Quintic:p,Sinusoidal:g,Exponential:y,Circular:f,Elastic:v,Back:E,Bounce:S},LayerBlendModes:D,DefaultLayerBlendMode:B,AnimationTypes:z};class TextToSpeechUtils{static autoGenerateSSMLMarks(e,t,i=[]){if("object"!=typeof t||null===t)throw new Error(`Cannot generate SSML marks for text "${e}" because map is not an object.`);const s=this._processInputMap(t),n=["<speak>","</speak>"],a=/<mark name=(?:"|')(.*?)(?:"|')\/>/,r=/<[^>]*>/g,o=[];let h=r.exec(e);for(;null!==h;)o.push({start:h.index,end:h.index+h[0].length,text:h[0]}),h=r.exec(e);const c=[];let l,u=0,d=[];o.forEach((t=>{const i=e.slice(u,t.start);if(""!==i&&(c.push(this._insertMarks(i,s,d)),d=[]),l=a.exec(t.text),null!==l){const e=l[1];d.push(e)}else n.includes(t.text)||c.push(t.text);u=t.end})),c.push(this._insertMarks(e.slice(u),s,d));let m=c.join("");return i&&i.length>0&&(m=this.addMarksToUnmarkedSentences(m,i)),TextToSpeechUtils.validateText(m)}static addMarksToUnmarkedSentences(e,t){if(!t||0===t.length)return e;const i=/<mark name=(?:"|')(.*?)(?:"|')\/>/g,s=/<[^>]*>/g,n=[];let a=i.exec(e);for(;null!==a;)n.push(a.index),a=i.exec(e);const r=[];let o=s.exec(e);for(;null!==o;)r.push({start:o.index,end:o.index+o[0].length,text:o[0]}),o=s.exec(e);let h=e.slice();r.forEach((e=>{const t=new Array(e.text.length+1).join(" ");h=[h.slice(0,e.start),t,h.slice(e.end)].join("")}));const c=this._getSentenceEnds(h);let l=0;const u=c.filter((e=>{const t=-1!==n.findIndex((t=>l<=t&&e>t));return l=e,!t}));return this._insertRandomMarksAt(e,u,t)}static validateText(e){return e=e?e.replace(/(^\s*<\s*speak\s*)>\s*|(^\s*)/,"<speak>").replace(/(\s*<\s*\/\s*speak\s*>\s*$|\s*$)/,"</speak>"):"<speak></speak>"}static _insertRandomMarksAt(e,i=[],s=[]){if(!s||0===s.length||!i||0===i.length)return e;let n=0;return i.forEach((i=>{const a=`<mark name='${s[t.getRandomInt(0,s.length)]}'/>`;e=[e.slice(0,i+n),a,e.slice(i+n)].join(""),n+=a.length})),e}static _getSentenceEnds(e){const t=/[^.!?]+[.!?]+/g,i=/[.!?]+/;let s=t.exec(e);const n=[];for(;null!==s;){const a=i.exec(s[0]);n.push(s.index+s[0].length-a[0].length),s=t.exec(e)}return n}static _insertMarks(e,t,i){if(""===e)return e;let s,n=!0;const a=e.match(/\w+|\s+|[^\s\w]+/g).map((e=>{if(s=e.toLowerCase(),t.has(s)){return`${t.get(s).map((e=>n?(n=!1,i.includes(e)?"":`<mark name='${e}'/>`):`<mark name='${e}'/>`)).join("")}${e}`}return n=!1,e}));return`${i.map((e=>`<mark name='${e}'/>`)).join("")}${a.join("")}`}static _processInputMap(e){const t=new Map;let i=[];return Object.entries(e).forEach((([s,n])=>{if(!Array.isArray(n))throw new Error(`Cannot generate SSML marks from map "${e}" because value for key '${s}' is not an array.`);n.forEach((e=>{const n=e.toLowerCase();i=t.get(n),void 0===i||i.includes(s)?t.set(n,[s]):t.set(n,[...i,s])}))})),t}}const ne=TextToSpeechUtils;const ae=class AbstractSpeech{constructor(e,t,i=[]){this._speaker=e,this._text=t,this._speechmarks=i,this._speechmarkOffset=0,this._reset()}_reset(e=0){this._startTime=e,this._localTime=0,this._pauseTime=0,this._playing=!1,this._markIter=this._speechmarks.values();const{value:t,done:i}=this._markIter.next();this._currentMark=t,this._endTime=this._speechmarks.length?this._speechmarks[this._speechmarks.length-1].time:0,this._done=i,this._promise=null}_createPromise(t,i,s){return this._promise=new e(void 0,(e=>{this._playing=!1,this._speaker.emit(this._speaker.constructor.EVENTS.stop,this),this._speaker.constructor.emit(this._speaker.constructor.EVENTS.stop,this),"function"==typeof t&&t(e)}),(e=>{this._playing=!1,this._speaker.emit(this._speaker.constructor.EVENTS.stop,this),this._speaker.constructor.emit(this._speaker.constructor.EVENTS.stop,this),console.error(`${this.constructor.name} encountered an unexpected error: ${e}`),"function"==typeof i&&i(e)}),(e=>{this._playing=!1,this._speaker.emit(this._speaker.constructor.EVENTS.interrupt,this),this._speaker.constructor.emit(this._speaker.constructor.EVENTS.interrupt,this),"function"==typeof s&&s(e)})),this._promise}_checkFinished(){return this._done&&this._localTime>=this._endTime}get playing(){return this._playing}get text(){return this._text}get speechmarks(){return[...this._speechmarks]}get speechmarkOffset(){return this._speechmarkOffset/1e3}set speechmarkOffset(e){this._speechmarkOffset=1e3*e}update(e){if(this._playing){if(this._localTime=e-this._startTime,!this._done)for(;!this._done&&this._currentMark.time+this._speechmarkOffset<=this._localTime;){this._speaker.emit(this._speaker.constructor.EVENTS[this._currentMark.type],{speech:this,mark:this._currentMark});const{value:e,done:t}=this._markIter.next();this._currentMark=e,this._done=t}this._checkFinished()&&(this.stop(),this._reset())}}play(e,t,i,s){return this._reset(e),this._playing=!0,this._speaker.emit(this._speaker.constructor.EVENTS.play,this),this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play,this),this._createPromise(t,i,s)}pause(e){this._playing=!1,this._pauseTime=e,this._speaker.emit(this._speaker.constructor.EVENTS.pause,this),this._speaker.constructor.emit(this._speaker.constructor.EVENTS.pause,this)}resume(e,t,i,s){return this._promise||(this._reset(e),this._createPromise(t,i,s)),this._playing=!0,this._startTime+=e-this._pauseTime,this._speaker.emit(this._speaker.constructor.EVENTS.resume,this),this._speaker.constructor.emit(this._speaker.constructor.EVENTS.resume,this),this._promise}cancel(){this._promise&&(this._promise.cancel(),this._promise=null),this._playing=!1}stop(){this._promise&&(this._promise.resolve(),this._promise=null),this._playing=!1}};const re=class Speech extends ae{constructor(e,t,i=[],s){super(e,t,i),this._audio=s.audio,this._audio.onended=()=>{this._audioFinished=!0},this._audioFinished=!0}_checkFinished(){return this._audioFinished&&super._checkFinished()}get audio(){return this._audio}get volume(){return this._audio.volume}set volume(e){this._audio.volume=e}_playAudio(){this._speechmarkOffset<0?(this._audio.currentTime=this._speechmarkOffset,setTimeout((()=>{this._playing&&(this._audio.currentTime=(this._localTime+this._speechmarkOffset)/1e3,this._audio.play())}),-this._speechmarkOffset)):(this._audio.currentTime=0,this._audio.play())}_pauseAudio(){this._audio.play().then((()=>{this._playing||this._audio.pause()}))}play(e,t,i,s){return this._audioFinished=!1,this._playAudio(),super.play(e,t,i,s)}pause(e){this._pauseAudio(),super.pause(e)}resume(e,t,i,s){return this._audioFinished=!1,this._audio.play(),super.resume(e,t,i,s)}cancel(){this._pauseAudio(),super.cancel()}stop(){this._pauseAudio(),this._audio.currentTime=0,super.stop()}},oe=["standard","neural"],he=["mp3","ogg_vorbis","pcm"],ce=["sentence","ssml","viseme","word"],le={mp3:{rates:["8000","16000","22050","24000"],defaults:{standard:"2050",neural:"2400"}},pcm:{rates:["8000","16000"],defaults:{standard:"1600",neural:"1600"}}};let ue;le.ogg_vorbis=le.mp3;class AbstractTextToSpeechFeature extends c{constructor(t,i={voice:void 0,engine:void 0,language:void 0,audioFormat:"mp3",sampleRate:void 0,speechmarkOffset:0,minEndMarkDuration:.05,volume:1,isGlobal:!1}){super(t),this._speechCache={},this._currentSpeech=null,this._currentPromise=null,this._isValidated=!1,this.speechmarkOffset=Number.isNaN(Number(i.speechmarkOffset))?0:Number(i.speechmarkOffset),this.minEndMarkDuration=Number.isNaN(Number(i.minEndMarkDuration))?0:Number(i.minEndMarkDuration),this.volume=Number.isNaN(Number(i.volume))?1:Number(i.volume),this._isGlobal=i.isGlobal||!1,this._promises={volume:e.resolve()},this._volumePaused=!1,this._voice=i.voice||this.constructor.POLLY_DEFAULTS.VoiceId,this._language=i.language||this.constructor.POLLY_DEFAULTS.LanguageName,this._engine=oe.includes(i.engine)?i.engine:this.constructor.POLLY_DEFAULTS.Engine,this._audioFormat=he.includes(i.audioFormat)?i.audioFormat:this.constructor.POLLY_DEFAULTS.OutputFormat,this._sampleRate=le[this._audioFormat].rates.includes(i.sampleRate)?i.sampleRate:this.constructor.POLLY_DEFAULTS.SampleRate}static initializeService(e,i,s){if(void 0===e||void 0===i||void 0===s)throw new Error("Cannot initialize TextToSpeech feature. All arguments must be defined.");e.config&&(e.config.customUserAgent=t.addCoreUserAgentComponent(e.config.customUserAgent),e.config.customUserAgent=t.addStringOnlyOnce(e.config.customUserAgent,this.prototype.getEngineUserAgentString())),i.service&&i.service.config&&(i.service.config.customUserAgent=t.addCoreUserAgentComponent(i.service.config.customUserAgent),i.service.config.customUserAgent=t.addStringOnlyOnce(i.service.config.customUserAgent,this.prototype.getEngineUserAgentString())),this._isReady=!1,this.SERVICES.polly=e,this.SERVICES.presigner=i,ue=s;const n=this.POLLY_VOICES;n.length=0;const a=this.POLLY_LANGUAGES;Object.keys(a).forEach((e=>{delete a[e]}));const r=this.POLLY_LANGUAGE_CODES;Object.keys(r).forEach((e=>{delete r[e]}));const o=this.POLLY_MIN_NEURAL_VERSION;return this.SERVICES.polly.describeVoices().promise().then((e=>{const t={};e.Voices.forEach((e=>{(e.SupportedEngines.includes("standard")||s>=o)&&n.push(e),n.forEach((e=>{a[e.LanguageName]=e.LanguageCode,t[e.LanguageCode]=e.LanguageName}))})),Object.entries(a).forEach((([e,t])=>{r[t]=e})),this._isReady=!0,this.emit(this.EVENTS.ready)}))}static get isReady(){return this._isReady}get currentSpeech(){return this._currentSpeech?this._currentSpeech.text:null}get speechmarkOffset(){return this._speechmarkOffset}set speechmarkOffset(e){this._speechmarkOffset=e,this._currentSpeech&&(this._currentSpeech.speechmarkOffset=e)}get minEndMarkDuration(){return this._minEndMarkDuration/1e3}set minEndMarkDuration(e){this._minEndMarkDuration=1e3*e}_validateEngine(e){return(void 0===e||this.constructor.AWS_VERSION<this.constructor.POLLY_MIN_NEURAL_VERSION)&&(e=this.constructor.POLLY_DEFAULTS.Engine),e}_validateFormat(e){return void 0!==e&&he.includes(e)||(e=this.constructor.POLLY_DEFAULTS.OutputFormat),e}_validateRate(e){return void 0!==e&&le[this._audioFormat].rates.includes(e)||(e=le[this._audioFormat].defaults[this._engine]),e}_validateVoice(e){const t=this.constructor.POLLY_VOICES.find((t=>t.Id===e));return void 0!==t&&t.SupportedEngines.includes(this._engine)||(e=this.constructor.POLLY_DEFAULTS.VoiceId),e}_validateLanguage(e){const t=this.constructor.POLLY_VOICES.find((e=>e.Id===this._voice)),i=this.constructor.POLLY_LANGUAGES[e],s=[t.LanguageCode];return t.AdditionalLanguageCodes&&s.push(...t.AdditionalLanguageCodes),s.includes(i)||(e=this.constructor.POLLY_LANGUAGE_CODES[t.LanguageCode]),e}_validate(){this._engine=this._validateEngine(this._engine),this._audioFormat=this._validateFormat(this._audioFormat),this._sampleRate=this._validateRate(this._sampleRate),this._voice=this._validateVoice(this._voice),this._language=this._validateLanguage(this._language),this._isValidated=!0}_getConfig(){return this.constructor.isReady&&!this._isValidated&&this._validate(),{Engine:this._engine,OutputFormat:this._audioFormat,SampleRate:this._sampleRate,VoiceId:this._voice,LanguageCode:this.constructor.POLLY_LANGUAGES[this._language]}}_updateConfig(e,t=[]){const i=this._getConfig();if(!e)return i;this._isValidated=!1;const s=JSON.stringify(i);e.Engine&&(this._engine=e.Engine),e.audioFormat&&(this._audioFormat=e.audioFormat),e.SampleRate&&(this._sampleRate=e.SampleRate),e.VoiceId&&(this._voice=e.VoiceId),e.Language&&(this._language=e.Language);const n=this._getConfig(),a=JSON.stringify(n);return s===a?(this._isValidated=!0,n):(Object.entries(this._speechCache).forEach((([e,i])=>{if(t.includes(e))return;JSON.stringify(i.config)!==a&&this._updateSpeech(e,n)})),n)}_updateSpeech(e,t,i=!1){const s=this._speechCache[e]||{};if(!i&&void 0!==t&&s.config&&JSON.stringify(t)===JSON.stringify(s.config))return s;const n={...t,Text:e,TextType:"ssml"},a={...n,OutputFormat:"json",SpeechMarkTypes:ce};return s.config=t,s.promise=Promise.all([this._synthesizeSpeechmarks(a),this._synthesizeAudio(n)]).then((t=>this._createSpeech(e,...t))),this._speechCache[e]=s,s}_createSpeech(e,t,i){return new ae(this,e,t,i)}_synthesizeAudio(t){return new e(((e,i)=>{this.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(t,(function(t,s){t?i(t):e({url:s})}))}))}_synthesizeSpeechmarks(e){return this.constructor.SERVICES.polly.synthesizeSpeech(e).promise().then((e=>{const t=JSON.stringify(e.AudioStream),i=JSON.parse(t).data.map((e=>String.fromCharCode(e))).join(""),s={sentence:[],word:[],viseme:[],ssml:[]},n={sentence:null,word:null,viseme:null,ssml:null},a=[...i.matchAll(/\{.*?\}(?=\n|$)/gm)].map((e=>{const t=JSON.parse(e[0]),i=s[t.type].length;if(i>0){const e=s[t.type][i-1];e.duration=t.time-e.time}return s[t.type].push(t),n[t.type]=t,t})),r=[];n.sentence&&r.push(n.sentence.time),n.word&&r.push(n.word.time),n.viseme&&r.push(n.viseme.time),n.ssml&&r.push(n.ssml.time);const o=Math.max(...r);return n.sentence&&(n.sentence.duration=Math.max(this._minEndMarkDuration,o-n.sentence.time)),n.word&&(n.word.duration=Math.max(this._minEndMarkDuration,o-n.word.time)),n.viseme&&(n.viseme.duration=Math.max(this._minEndMarkDuration,o-n.viseme.time)),n.ssml&&(n.ssml.duration=Math.max(this._minEndMarkDuration,o-n.ssml.time)),a}))}_getSpeech(t,i){if(!this.constructor.isReady){const t="AWS services have not been initialized.";return e.reject(t)}if(!t){const t="Cannot play a speech with no text.";return e.reject(t)}return t=ne.validateText(t),i=this._updateConfig(i,t),this._updateSpeech(t,i).promise}installApi(){const e=super.installApi();return Object.assign(e,{play:this.play.bind(this),pause:this.pause.bind(this),resume:this.resume.bind(this),stop:this.stop.bind(this),getVolume:this.getVolume.bind(this),setVolume:this.setVolume.bind(this),pauseVolume:this.pauseVolume.bind(this),resumeVolume:this.resumeVolume.bind(this)}),Object.defineProperties(e,{speechmarkOffset:{get:()=>this.speechmarkOffset,set:e=>{this.speechmarkOffset=e}}}),e}set volume(e){this._volume=r.clamp(e)}get volume(){return this._volume}get volumePending(){return this._promises.volume&&this._promises.volume.pending}getVolume(){return this.volume}setVolume(e,t=0,i){return this.volumePending&&this._promises.volume.cancel(),e=r.clamp(e),this._promises.volume=O.interpolateProperty(this,"volume",e,{seconds:t,easingFn:i}),this._promises.volume}pauseVolume(){return this._volumePaused=!0,this.volumePending}resumeVolume(){return this._volumePaused=!1,this.volumePending}update(e){this._volumePaused||this._promises.volume.execute(e),this._currentSpeech&&this._currentSpeech.playing&&(this._currentSpeech.volume=this._volume,this._currentSpeech.update(this._host.now),super.update(e))}_setCurrentSpeech(e){e.speechmarkOffset=this._speechmarkOffset,this._currentSpeech=e}_startSpeech(t,i,s="play"){void 0===t&&"resume"===s&&this._currentSpeech&&(t=this._currentSpeech.text);const n=this._currentPromise||{play:new e(void 0,(()=>{n.speech.cancel()}),(()=>{n.speech.cancel()}),(()=>{n.speech.cancel()})),speech:new e};return this._currentPromise=n,this._getSpeech(t,i).then((e=>{if(!n.play.pending)return;if(this._currentPromise!==n)return void n.play.cancel();const t=()=>{this._currentSpeech=null,this._currentPromise=null};this._currentSpeech&&this._currentSpeech.playing&&("play"===s||"resume"===s&&this._currentSpeech.audio!==e.audio)&&this._currentSpeech.cancel(),this._setCurrentSpeech(e),n.speech=e[s](this._host.now,t,t,t),n.speech.then((()=>{n.speech.resolved?n.play.resolve():n.play.cancel()})).catch((e=>{n.play.reject(e)}))})).catch((e=>{e=`Cannot ${s} speech ${t} on host ${this.host.id}. ${e}`,n.play.reject(e)})),n.play}play(e,t){return this._startSpeech(e,t,"play")}pause(){this._currentSpeech&&this._currentSpeech.playing?this._currentSpeech.pause(this._host.now):console.warn(`Cannot pause speech on host ${this.host.id}. No speech is currently playing`)}resume(e,t){return this._startSpeech(e,t,"resume")}stop(){this._currentSpeech&&this._currentSpeech.playing?(this._currentSpeech.stop(),this._currentSpeech=null):console.warn(`Cannot stop speech on host ${this.host.id}. No speech is currently playing.`)}discard(){this._currentSpeech&&this._currentSpeech.playing&&this._currentSpeech.stop(),delete this._speechCache,super.discard()}getEngineUserAgentString(){return"UnknownEngine"}}Object.defineProperties(AbstractTextToSpeechFeature,{AWS_VERSION:{get:()=>ue},POLLY_MIN_NEURAL_VERSION:{value:"2.503",writable:!1},POLLY_DEFAULTS:{value:{Engine:"standard",LexiconNames:[],OutputFormat:"mp3",SampleRate:"22050",Text:"",TextType:"ssml",VoiceId:"Amy",LanguageCode:"en-GB",LanguageName:"British English"},writable:!1},POLLY_VOICES:{value:[],writable:!1},POLLY_LANGUAGES:{value:{},writable:!1},POLLY_LANGUAGE_CODES:{value:{},writable:!1},_isReady:{value:!1,writable:!0},EVENTS:{value:{...Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS,ready:"onReadyEvent",play:"onPlayEvent",pause:"onPauseEvent",resume:"onResumeEvent",interrupt:"onInterruptEvent",stop:"onStopEvent",sentence:"onSentenceEvent",word:"onWordEvent",viseme:"onVisemeEvent",ssml:"onSsmlEvent"}},SERVICES:{value:{...Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES,polly:void 0,presigner:void 0}}});const de=AbstractTextToSpeechFeature;const me=class TextToSpeechFeature extends de{constructor(...e){super(...e),this._enabled=!1,this._setAudioContext(),this._observeAudioContext()}_setAudioContext(){this._audioContext=new AudioContext}_observeAudioContext(){this._audioContext&&(this._audioContext.onstatechange=()=>{"running"===this._audioContext.state?this._enabled=!0:(this._enabled=!1,console.warn('The audio context is not running. Speech will not be able to be played until it is resumed. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.'))},this._audioContext.onstatechange())}_synthesizeAudio(e){return super._synthesizeAudio(e).then((e=>{const{url:t}=e,i=new Audio(t);return i.loop=this.loop,i.crossOrigin="anonymous",i.preload="auto",e.audio=i,new Promise((t=>{i.addEventListener("canplaythrough",(()=>{t(e)})),document.body.appendChild(i),i.load()}))}))}_createSpeech(e,t,i){return new re(this,e,t,i)}get enabled(){return this._enabled}resumeAudio(){return new e(((e,t)=>{this._audioContext.resume().then((()=>{this._enabled=!0,e()})).catch((e=>{this._enabled=!1,t(e)}))}))}_startSpeech(t,i,s="play"){const n={play:new e(void 0,(()=>{n.speech.cancel()}),(()=>{n.speech.cancel()}),(()=>{n.speech.cancel()})),speech:new e};return this._currentPromise=n,this.resumeAudio().then((()=>{n.play.pending&&(this._currentPromise===n?this._enabled?super._startSpeech(t,i,s):n.reject(new Error(`Cannot ${s} speech on host ${this._host.id}. The audio context is not running. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.`)):n.play.cancel())})),n.play}play(e,t){return this._startSpeech(e,t,"play")}resume(e,t){return this._startSpeech(e,t,"resume")}installApi(){const e=super.installApi();return Object.defineProperties(e,{enabled:{get:()=>this._enabled}}),e}};const _e=class LexUtils{static downsampleAudio(e,t,i){if(!e||!e.length)return;if(t===i)return e;if(t<i)throw Error(`Input Sample rate ${t} is less than target sample rate ${i}.`);const s=e.length,n=t/i,a=Math.round(s/n),r=new Float32Array(a);let o=0,h=0;for(;o<a;){const t=Math.round((o+1)*n);let i=0,a=0;for(let n=h;n<t&&n<s;n++)i+=e[n],a++;r[o]=i/a,o++,h=t}return r}static encodeWAV(e,t){function i(e,t,i){for(let s=0;s<i.length;s++)e.setUint8(t+s,i.charCodeAt(s))}if(!e)return;const s=new ArrayBuffer(44+2*e.length),n=new DataView(s);return i(n,0,"RIFF"),n.setUint32(4,32+2*e.length,!0),i(n,8,"WAVE"),i(n,12,"fmt "),n.setUint32(16,16,!0),n.setUint16(20,1,!0),n.setUint16(22,1,!0),n.setUint32(24,t,!0),n.setUint32(28,2*t,!0),n.setUint16(32,2,!0),n.setUint16(34,16,!0),i(n,36,"data"),n.setUint32(40,2*e.length,!0),function(e,t,i){for(let s=0;s<i.length;s++,t+=2){const n=Math.max(-1,Math.min(1,i[s]));e.setInt16(t,n<0?32768*n:32767*n,!0)}}(n,44,e),n}};class LexFeature extends h{constructor(e,i={botName:void 0,botAlias:void 0,userId:void 0}){if(super(),!e)throw Error("Cannot initialize Lex feature. LexRuntime must be defined");e.config&&(e.config.customUserAgent=t.addCoreUserAgentComponent(e.config.customUserAgent),e.config.customUserAgent=t.addStringOnlyOnce(e.config.customUserAgent,this.getEngineUserAgentString())),this._lexRuntime=e,this._botName=i.botName,this._botAlias=i.botAlias,this._userId=i.userId?i.userId:t.createId(),this._micReady=!1,this._recording=!1,this._recLength=0,this._recBuffer=[],this._setupAudioContext()}_setupAudioContext(){this._audioContext=new AudioContext}_processWithAudio(e,t,i={}){const s=this._prepareAudio(e,t);return this._process("audio/x-l16; rate=16000",s,i)}processWithText(e,t={}){return this._process("text/plain; charset=utf-8",e,t)}_process(e,t,i){const s=this._validateConfig(i),n={botName:s.botName,botAlias:s.botAlias,contentType:e,inputStream:t,userId:s.userId};return new Promise(((e,t)=>{this._lexRuntime.postContent(n,((i,s)=>i?t(i):e(s)))})).then((e=>(this.emit(this.constructor.EVENTS.lexResponseReady,e),e)))}_validateConfig(e){const t={};if(t.botName=e.botName?e.botName:this._botName,t.botAlias=e.botAlias?e.botAlias:this._botAlias,t.userId=e.userId?e.userId:this._userId,!t.botName||!t.botAlias||!t.userId)throw new Error("Cannot process lex request. All arguments must be defined.");return t}_prepareAudio(e,t){const i=_e.downsampleAudio(e,t,this.constructor.LEX_DEFAULTS.SampleRate),s=_e.encodeWAV(i,this.constructor.LEX_DEFAULTS.SampleRate);return new Blob([s],{type:"application/octet-stream"})}async enableMicInput(){const e=await navigator.mediaDevices.getUserMedia({audio:!0,video:!1}),t=this._audioContext.createMediaStreamSource(e),i=this._audioContext.createScriptProcessor(4096,1,1);i.onaudioprocess=e=>{if(!this._recording)return;const t=e.inputBuffer.getChannelData(0);this._recBuffer.push(new Float32Array(t)),this._recLength+=t.length},t.connect(i),i.connect(this._audioContext.destination),this.emit(this.constructor.EVENTS.micReady),this._micReady=!0}beginVoiceRecording(){this._micReady&&("suspended"!==this._audioContext.state&&"interrupted"!==this._audioContext.state||this._audioContext.resume(),this._recLength=0,this._recBuffer=[],this._recording=!0,this.emit(this.constructor.EVENTS.recordBegin))}endVoiceRecording(){if(!this._recording)return Promise.resolve();this._recording=!1;const e=new Float32Array(this._recLength);let t=0;for(let i=0;i<this._recBuffer.length;i++)e.set(this._recBuffer[i],t),t+=this._recBuffer[i].length;return this.emit(this.constructor.EVENTS.recordEnd),this._processWithAudio(e,this._audioContext.sampleRate)}getEngineUserAgentString(){return"UnknownEngine"}}Object.defineProperties(LexFeature,{LEX_DEFAULTS:{value:{SampleRate:"16000"},writable:!1},EVENTS:{value:{...Object.getPrototypeOf(LexFeature).EVENTS,lexResponseReady:"lexResponseReady",micReady:"micReady",recordBegin:"recordBegin",recordEnd:"recordEnd"}}});const pe={LexFeature,LexUtils:_e,AbstractTextToSpeechFeature:de,TextToSpeechFeature:me,TextToSpeechUtils:ne,AbstractSpeech:ae,Speech:re},ge=t.getVersion(),{Easing:ye,AnimationFeature:fe,AnimationTypes:ve,AnimationLayer:Ee,LayerBlendModes:Se,DefaultLayerBlendMode:be,SingleState:Ae,TransitionState:we,FreeBlendState:Te,QueueState:Le,RandomAnimationState:Ne,Blend1dState:xe,Blend2dState:Fe,AnimationUtils:ke}=se,{LexFeature:Oe,LexUtils:Me,AbstractTextToSpeechFeature:Ce,TextToSpeechFeature:Ie,TextToSpeechUtils:Pe,AbstractSpeech:$e,Speech:Ve}=pe})(),s})()));